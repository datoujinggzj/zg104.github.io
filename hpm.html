<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LSTM RUL论文</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__html"><h1 id="基于-lstm-的设备健康评估与剩余寿面预测的研究">基于 LSTM 的设备健康评估与剩余寿面预测的研究</h1>
<h2 id="目录">目录</h2>
<h3 id="第一部分-phm-介绍">第一部分 PHM 介绍</h3>
<p>1.1 <a href="#1">研究背景</a><br>
1.2 <a href="#2">PHM 概述</a><br>
1.3 <a href="#3">研究现状和发展趋势</a></p>
<h3 id="第二部分-理论与技术">第二部分 理论与技术</h3>
<p>2.1 <a href="#21">数据驱动 RUL 预测框架</a><br>
2.2 <a href="#22">自动变分编码器</a><br>
2.3 <a href="#23">长短时记忆网络</a></p>
<h3 id="第三部分-健康状况评估建模">第三部分 健康状况评估建模</h3>
<p>3.1 健康状况评估概述</p>
<hr>
<h2 id="第一部分-phm-介绍-1">第一部分 PHM 介绍</h2>
<h3 id="font-id--1研究背景font"><font id="1">研究背景</font></h3>
<p>PHM 核心在于基于状态监测数据，用智能算法来实时评估健康状况以及预测设备剩余使用寿命（Remaining Useful Life, RUL），并制定长期维护计划。<a href="https://nndl.github.io/ppt/chap-%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C.pptx">长短期记忆网络(LSTM)</a> 作为循环神经网络的延伸算法，在端对端学习上效果突出，并由于其对时期依赖的特征提取优势，可以在 PHM 的时序预测问题上有所贡献。</p>
<ol>
<li>
<p>LSTM + <a href="https://zhuanlan.zhihu.com/p/27549418">VAE（变分自编码器）</a>的混合模型；</p>
<p>LSTM 的引入可有效提取时序数据中的长短期时间依赖性特征，另外结合 VAE 的数据降维能力，可以对复杂的波动、图像数据等进行解码、再编码从而在保留数据大部分信息的情况下，大幅度减少其数据维度并对数据压缩，达到数据去噪、可视化降维的效果。</p>
</li>
<li>
<p>多层 LSTM 直接预测 RUL</p>
</li>
<li>
<p>搭建基于 Azure 云平台的健康管理系统 pipeline</p>
</li>
</ol>
<hr>
<h3 id="font-id--2phm-概述font"><font id="2">PHM 概述</font></h3>
<p>深度学习在 HPM 领域的研究和应用仍处于探索阶段，尤其在航空航天领域。</p>
<p>PHM <strong>核心问题</strong>在于</p>
<ol>
<li>
<p>对于海量数据的监测：数据量大，并且维数高，要求算法有强大的泛化能力和鲁棒性，并且能高效处理大规模数据。</p>
</li>
<li>
<p>特征工程：包含特征选择、特征转换、特征增强等等，这个占据整个项目的60%的功夫，因为航天数据包含波动、图像、时序、结构性数据等等类型，所以需要对数据进行降维和转换，转化成可用的有效输入。</p>
</li>
<li>
<p>预测 RUL：对于剩余有效寿命的预测例子已经不少，但是一般是在齿轮、轴承上的，对于航天的零件组成和系统的预测会十分复杂，难点在于异常数据的获取成本极高，训练集样本数较少，训练神经网络需要大量数据，否则效果较差。</p>
</li>
</ol>
<p><strong>数据分析、建模流程图：</strong></p>
<img src="https://pic.downk.cc/item/5fdb2ad93ffa7d37b3869061.jpg">
<p><strong>PHM 基本组成结构流程图：</strong></p>
<img src="https://pic.downk.cc/item/5fdc5aa83ffa7d37b360a9ea.jpg">
<p>PHM 基本组成结构及流程如上图所示，具体而言：</p>
<ol>
<li>
<p>PHM 借助先进传感器技术采集表征系统属性的各类状态数据，利用各种信号处理等技术（傅里叶变换、小波变换等）对数据进行预处理或特征工程，获得反映系统性能退化的特征；</p>
</li>
<li>
<p>随后，融合提取的特征对设备进行健康状况评估，预测设备的失效时刻；</p>
</li>
<li>
<p>最终，基于 RUL 预测结果，将费用最小化作为目标进行维护规划，并结合已有的维修资源，合理安排维修活动，确定最佳健康管理措施。</p>
</li>
</ol>
<p>HPM 重点或者说需要突破的点在于：</p>
<ol>
<li>精准地评估系统的健康状况</li>
<li>实时追踪性能退化轨迹并可靠地预测 RUL</li>
</ol>
<h3 id="font-id--3研究现状和发展趋势font"><font id="3">研究现状和发展趋势</font></h3>
<h4 id="健康状况评估研究现状">健康状况评估研究现状</h4>
<p>本质上，健康状况评估基于状态监测数据，对系统性能退化状态进行建模，从而构建一维健康值曲线（HI 曲线），来表征性能退化或偏离程度。有效的健康状况评估算法不仅能够从状态监测实时变化中评估当前系统状况、追踪性能退化轨迹，在故障早期进行预警，也可以为下一步 RUL 预测提供先验信息，提高预测准确性。</p>
<p>构造 HI 曲线有两种策略，可分为直接法和间接法。</p>
<p>直接法：</p>
<p>通过统计分析或者特征提取，直接构造出具有一定<strong>物理意义</strong>的健康值，比如直接提取机械设备的振动信号、从小波数据中提取 RMS 和峰值、从传感器信号的频域提取一些相关特征等等。</p>
<p>间接法：</p>
<p>利用机器学习对传感器时域特征或频域特征进行融合或降维得到的，不具备物理意义，也称为虚拟 HI。使用主成分分析、线性判别分析等等来对特征进行降维，并将位置状态与健康状态之间的偏差作为 HI 值。</p>
<h4 id="剩余寿命预测研究现状与发展趋势">剩余寿命预测研究现状与发展趋势</h4>
<p>PHM 中的 prognostics 表示预测剩余使用寿命。剩余使用寿命是指在役设备系统以当前运行条件，能够继续实现其既定功能的剩余可操作时间。其预测目的，是估计一种或多种未来故障发生的时间或风险，为进一步制定维修维护计划提供关键决策信息。</p>
<p>RUL 的预测目标是根据历史检测传感器数据来确定设备系统的剩余可操作时间。</p>
<p>其预测算法模型主要可分三种：基于物理模型、基于数据驱动、基于混合模型</p>
<ul>
<li>
<p>基于物理模型：是指根据设备系统的失效机制或性能退化过程来建立精确的动态数学模型，也就是建立一种描述系统输入和输出之间的映射关系，从而通过传感器检测数据的变动来时间设备系统剩余可操作性时间的预测。</p>
<p>优点：<br>
（1）在系统失效机制简单，且设备系统结构和动态特性已知的前提下，基于物理模型的方法能够进行准确快速地预测；<br>
（2）该方法建立了系统的近似数学模型，模型参数又与系统的物理量相关联，使得预测结果可解释性强。</p>
<p>缺点：<br>
飞机设备系统规模较大，更加智能化，系统的故障模式和机理更加复杂，数据复杂度和维数也会随之增加，想要建立精准的可解释的模型几乎不可能。</p>
</li>
<li>
<p>基于数据驱动：大数据时代背景下的产物，也是研究热点，随着传感器的进步与发展，通过其获取全生命周期数据已不再是梦想，数据驱动法不需过度依赖于传统的专业知识和物理模型的解释，而是直接建立于传感器检测数据本身，以数据为本，运用信号处理等技术对其进行数据分析和挖掘，提取反映系统退化失效的特征，从而借助于人工智能算法实现对设备的 RUL 预测。常见的数据驱动方法有：</p>
<ul>
<li>基于数理统计：如自回归移动平滑（ARIMA）对时序数据的自相关性、周期性来分析和预测，利用马尔科夫生成随机过程模型，引入隐变量以及 EM 算法来估计参数以及其他方法。为了描述不可观测或位置因素引起的不确定性，通常也将随机方差作为模型参数引入。因此，基于数理统计理论的方法可有效地描述系统退化过程的不确定性及其对 RUL 的影响。</li>
<li>基于机器学习：典型的算法有高斯过程、人工神经网络、支持向量机、深度学习等。近年来神经网络和马尔科夫蒙特卡洛采样算法在对涡轮发动机 RUL 预测方面有不小的贡献。</li>
<li>基于混合模型：融合了物理模型和数据驱动两种方法，取长补短，通过各个模型的优势来整合从而提升模型的精度。实现过程较为复杂，实际场景应用较少。</li>
</ul>
</li>
</ul>
<h4 id="深度学习在-phm-领域的研究现状">深度学习在 PHM 领域的研究现状</h4>
<p>深度学习作为机器学习的重要分支，伴随着深度神经网络理论的发展和演进，深层次模型（上百层神经网络）也成为可能。通过多层隐藏层的特征提取能力和非线性能力，深度学习使得在诸多传统机器学习领域解决不好的问题，得到了极大的改善并取得了优异的成果。</p>
<p>面对航空航天方面的 RUL 预测问题，有以下几个不可忽略的问题：</p>
<ol>
<li>面对复杂运行工况下的设备系统未给出合理的建模方案</li>
<li>RUL 预测结果缺少不确定度表达</li>
<li>部分算法仍然依赖人工提取特征</li>
<li>预测模型未考虑到传感器监测数据存在的时间依赖性</li>
</ol>
<hr>
<h2 id="相关理论和技术">相关理论和技术</h2>
<h3 id="font-id--21数据驱动-rul-预测框架font"><font id="21">数据驱动 RUL 预测框架</font></h3>
<img src="https://pic.downk.cc/item/5fe00a733ffa7d37b31ad205.jpg">
<p>较为完整的复杂设备系统的数据驱动 RUL 预测框架往往会涵盖在线应用和离线建模两个阶段，两个部分相互补充，相互支持。</p>
<p>离线阶段，充分利用设备系统的测试数据、历史监测数据。系统部件的数学物理模型等等，建立面向线上实际应用的运行工况识别，数据预处理、特征工程、退化状态识别等；</p>
<p>在线阶段，对实时监测收集到的数据进行必要的数据预处理和特征工程等操作后，依据在役设备实际的运行环境，通过算法预测系统 RUL。</p>
<p>简单来说，我们通过离线阶段对模型进行建模、训练、学习，而通过在线阶段对模型来进行实时调整从而对模型进行动态优化。</p>
<p>一般来说有两种 RUL 预测策略：</p>
<ol>
<li>把 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">m</span></span></span></span></span> 维特征映射为单维 HI 值曲线，采用曲线拟合、外推等方式来预测（间接预测）</li>
<li>采用直接对原始多维数据进行特征提取，来预测剩余寿命（直接预测）</li>
</ol>
<h4 id="步骤-1-数据采集（data-aquization）">步骤 1 数据采集（Data Aquization）</h4>
<p>随着传感器技术和数据库存储技术的发展，设备系统海量的状态检测数据的手机和存储成为可能。有效的数据采集是保证数据驱动方法成功的基础，只有提供充足且有价值的数据才能挖掘反映系统退化过程的特征，训练有效的模型和参数。</p>
<h4 id="步骤-2-数据预处理（data-pre-processing）">步骤 2 数据预处理（Data Pre-processing）</h4>
<p>通过对采集的原始数据进行清洗，来降低异常数据的干扰（孤立森林，LOF(Local Outlier Factor)等），坚决避免 “垃圾进，垃圾出” 。针对不同工况下的数据来进行标准化处理，整合碎片化数据，并建立建模所用的数据集以及数据可视化、探索性分析等等，目的是通过预处理环节对数据进行净化和分析为接下来的步骤打好基础。</p>
<p align="center">
	  <img src="https://media.geeksforgeeks.org/wp-content/uploads/20190312184006/Data-Preprocessing.png">
</p>
<h4 id="步骤-3-特征工程">步骤 3 特征工程</h4>
<p>特征工程占据了整个项目的 70% 的比重，我们大部分的时间和精力都花在了特征工程上面，其中包括特征提取、特征选择、降维、数据融合等等。通过数据分析、信号处理以及领域专业知识。</p>
<p><img src="https://elitedatascience.com/wp-content/uploads/2018/05/What-Goes-Into-a-Successful-Model.jpg" alt="What Goes Into a Successful Model"></p>
<p>特征工程其实也是一个增加有效特征的过程，可以理解为数据清洗是一个筛选（减少）数据的过程，而相反，特征工程是增加的过程。对于提升一个模型表现来说，有几个方法：</p>
<ol>
<li>可以分离或者高亮更重要的关键信息</li>
<li>自己的相关的行业或者领域知识</li>
<li>别人的经验和相关知识</li>
</ol>
<p>关于特征工程，我们可以：</p>
<ul>
<li>注入领域知识：比如我们通过对飞机制造、结构、运转等等数据驱动之外的领域知识来注入更多的信息到模型里面</li>
<li>创建交互特征：交互自然是两个或多个特征的交互信息，合并起来又降低了维度，也能减少共线性，更能突出其特征的代表能力，反而有更好的效果</li>
<li>增加虚拟变量：对于类别型特征，我们往往要转换成虚拟变量（dummy variables）</li>
<li>移除无用变量：根据经验和信息重要程度对特征进行选择和筛选</li>
</ul>
<h4 id="步骤-4-健康状况评估">步骤 4 健康状况评估</h4>
<p>健康状况评估本质上是将原始多维数据或特征映射到能表征设备系统健康状况的一维向量上，或者从性能变量中直接选择表征系统健康状况的参量，一般才用数据融合方法对系统退化状态来建模，例如主成分分析（PCA） 、自组织映射神经网络（SOM）等，从而获取表征对象系统健康状况的健康值曲线。</p>
<h4 id="rul-预测">RUL 预测</h4>
<p>RUL 预测是 PHM 中核心功能模块，选择一个合适的算法是决定剩余寿命预测性能的关键之一，或使用间接法，构造出健康值曲线然后采用外推方式预测；另一种是建模多维特征与真实 RUL 的映射关系。</p>
<h4 id="健康管理">健康管理</h4>
<p>根据得到的 RUL 预测结果，结合不同设备系统的需求及现有的维修资源，及时产生故障预警信号，或规划合理的维修维护活动。</p>
<img src="https://pic.downk.cc/item/5fe199053ffa7d37b33d93da.jpg">
<hr>
<h3 id="font-id--22变分自动编码器（vae）font"><font id="22">变分自动编码器（VAE）</font></h3>
<img src="https://pic.downk.cc/item/5fe19ad63ffa7d37b33f44b8.jpg">
<p>自动编码器 (AutoEncoder) 最开始作为一种数据的压缩方法，其特点有:</p>
<p>（1）<strong>跟数据相关程度很高</strong>，这意味着自动编码器只能压缩与训练数据相似的数据，这个其实比较显然，因为使用神经网络提取的特征一般是高度相关于原始的训练集，使用人脸训练出来的自动编码器在压缩自然界动物的图片是表现就会比较差，因为它只学习到了人脸的特征，而没有能够学习到自然界图片的特征；那么在航空航天方面，自然我们要处理一些高清的精密仪器或者系统的图像数据，我们不想直接用神经网络来提取特征，维度会很高，所以可以使用自动编码器先对图像做压缩降维处理。</p>
<p>（2）<strong>压缩后数据是有损的</strong>，这是因为在降维的过程中不可避免的要丢失掉信息；那么图像数据尽管有损，但也保存了绝大多数信息，从而大幅度提升模型训练效率。</p>
<p>所以现在自动编码器主要应用有两个方面，<strong>第一是数据去噪，第二是进行可视化降维</strong>。然而自动编码器还有着一个功能就是<strong>生成数据</strong>。</p>
<h4 id="自动编码器的结构">自动编码器的结构</h4>
<p>首先我们给出自动编码器的一般结构</p>
<p><img src="https://pic2.zhimg.com/80/v2-e5745659cd57562c1dcfc3de7e2a4229_1440w.png" alt=""></p>
<p>从上面的图中，我们能够看到两个部分，第一个部分是编码器 (Encoder)，第二个部分是解码器 (Decoder)，编码器和解码器都可以是任意的模型，通常我们使用神经网络模型作为编码器和解码器。输入的数据经过神经网络<strong>降维</strong>到一个编码 (code)，接着又通过另外一个神经网络去解码得到一个与输入原数据一模一样的生成数据，然后通过去比较这两个数据，最小化他们之间的差异来训练这个网络中编码器和解码器的参数。当这个过程训练完之后，我们可以拿出这个解码器，随机传入一个编码 (code)，希望通过解码器能够生成一个和原数据差不多的数据，上面这种图这个例子就是希望能够生成一张差不多的图片。</p>
<p>接下来，我们系统地讲解一下自动编码器。它使一个无监督算法，用于降维或特征提取。左侧编码过程从原始输入数据 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">x</span></span></span></span></span> 中学习到其隐含特征向量 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault">h</span></span></span></span></span>，因此编码器可由函数 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h = f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span></span> 表示；相反，右侧解码器 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo>=</mo><mi>g</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">r = g(h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">r</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mclose">)</span></span></span></span></span> 则根据隐空间的隐变量 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault">h</span></span></span></span></span> 重构出原始输入向量，记为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">r</span></span></span></span></span>。通常不会设计自动编码器的结构使输入向量完全与输出向量相等，而是引入一些约束条件让重构向量 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">r</span></span></span></span></span> 近似等同于输入向量 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">x</span></span></span></span></span>。一种常见的约束是，隐含层向量维度小于输入层向量维度，这样 AE 迫使编码器提取原始数据中更有用的特征，其学习过程可理解为代价函数最小化的优化过程，保证重购数据和原始输入误差最小</p>
<p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>min</mi><mo>⁡</mo><mo stretchy="false">{</mo><mi>L</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>g</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\min \{ L(x,g(f(x)) \}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mop">min</span><span class="mopen">{</span><span class="mord mathdefault">L</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">}</span></span></span></span></span></span></p>
<p>其中，<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">x</span></span></span></span></span> 是输入向量，<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span></span></span></span></span> 表示编码过程，<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span></span></span></span></span> 是解码过程，<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault">L</span></span></span></span></span> 是代价函数，通常是均方误差函数。</p>
<p align="center">
	  <img src="https://pic.downk.cc/item/5fe1ae0e3ffa7d37b3522c7d.jpg" width="500">
</p>
<p>上述编码器的功能与主成分分析方法类似。本质上，当编码器函数 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span></span></span></span></span> 是线性函数且采用均方根误差函数时，自动编码器会学习到和主成分分析相同的生成子空间。但是在自动编码器实际使用中，无论是 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span></span></span></span></span> 还是 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span></span></span></span></span> 都会使用非线性激活函数。因此，相比较于 PCA，此时的自动编码器能够学习出更为强大的非线性流形。</p>
<p><img src="https://pic1.zhimg.com/80/v2-d72d012f50ad64ff3a7de3e7e6c56a64_1440w.png" alt=""></p>
<h4 id="变分自动编码器-variational-autoencoder">变分自动编码器 (Variational Autoencoder)</h4>
<p>变分编码器是自动编码器的升级版本，其结构跟自动编码器是类似的，也由编码器和解码器构成。</p>
<p>回忆一下我们在自动编码器中所做的事，我们需要输入一张图片，然后将一张图片编码之后得到一个隐含向量，这比我们随机取一个随机噪声更好，因为这包含着原图片的信息，然后我们隐含向量解码得到与原图片对应的照片。</p>
<p>但是这样我们其实并不能任意生成图片，因为我们没有办法自己去构造隐藏向量，我们需要通过一张图片输入编码我们才知道得到的隐含向量是什么，这时我们就可以通过变分自动编码器来解决这个问题。</p>
<p>其实原理特别简单，只需要在编码过程给它增加一些限制，迫使其生成的隐含向量能够粗略的遵循一个标准正态分布，这就是其与一般的自动编码器最大的不同。</p>
<p>这样我们生成一张新图片就很简单了，我们只需要给它一个标准正态分布的随机隐含向量，这样通过解码器就能够生成我们想要的图片，而不需要给它一张原始图片先编码。</p>
<p>VAE 的结果比普通的自动编码器要好很多，下面是结果</p>
<p><img src="https://pic4.zhimg.com/80/v2-b413f4babc81c9cbfbb6b7af60da08a7_1440w.png" alt=""></p>
<p><img src="https://pic2.zhimg.com/80/v2-1d4fef666ab0fe9b403e4fb808252b8d_1440w.png" alt=""></p>
<p>VAE的缺点也很明显，他是直接计算生成图片和原始图片的均方误差而不是像GAN那样去对抗来学习，这就使得生成的图片会有点模糊。现在已经有一些工作是将VAE和GAN结合起来，使用VAE的结构，但是使用对抗网络来进行训练，具体可以参考一下这篇<a href="https://link.zhihu.com/?target=https%3A//arxiv.org/pdf/1512.09300.pdf">论文</a>。</p>
<p>那么在自动编码器中，编码器将输入向量非线性映射到中间隐含层获得编码向量，解码器随后尽可能低误差地重购原始数据。其中最关键一点，自动编码器迫使编码器学习原始数据中最显著的特征（隐含层维数更小），因此，编码特征向量中每一个维度都代表着相应隐变量的具体取值。不同的是，变分自编码器（VAE）结合了概率统计学和深度学习理论，以概率分布来描述输入数据的隐空间，通过训练得到的编码向量描述的事隐变量概率分布，而不仅仅是具体数值。<br>
区别如下：</p>
<p align="center">
	  <img src="https://pic.downk.cc/item/5fe1b8d73ffa7d37b35c9497.jpg" width="800">
</p>
<p>结合上图中的隐变量形式，可以看出，VAE 是将原始输入数据对应的每个隐变量都编码表示为<strong>概率分布形式</strong>。当解码器模块从隐空间进行重构原始输入时，会在对应隐变量的概率分布上随机采样。因此，对于 VAE 来说，也将编码器称为识别模型或推断模型，而解码器称为生成模型，VAE 也被认为是<strong>生成式模型</strong>。</p>
<h4 id="隐变量模型">隐变量模型</h4>
<p>对于训练样本集，我们希望能够学习到其概率分布，如果可行的话，可以根据概率分布（威布尔分布）来生成新样本或者判断新样本是否偏离正常数据分布等。</p>
<blockquote>
<p>Weibull分布（威布尔分布）</p>
</blockquote>
<p><img src="
https://pic.downk.cc/item/5fe2b20f3ffa7d37b3fd576a.jpg" width="400/"></p>
<blockquote>
<p>其中，<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">x</span></span></span></span></span> 是随机变量，<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>λ</mi><mi mathvariant="normal">＞</mi><mn>0</mn></mrow><annotation encoding="application/x-tex">λ＞0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault">λ</span><span class="mord cjk_fallback">＞</span><span class="mord">0</span></span></span></span></span> 是比例参数（scale parameter），<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mi mathvariant="normal">＞</mi><mn>0</mn></mrow><annotation encoding="application/x-tex">k＞0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span><span class="mord cjk_fallback">＞</span><span class="mord">0</span></span></span></span></span> 是形状参数（shape parameter）。显然，它的累积分布函数是扩展的指数分布函数，而且，Weibull distribution与很多分布都有关系。如，当 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span>，它是指数分布；k=2时，是Rayleigh distribution (瑞利分布)。</p>
</blockquote>
<p>但往往这种假设不一定在实际中成立，是一种理想情况，实际应用中很难获得样本集的真实分布。所以，VAE 假设样本集中任一样本 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.07847em;">X</span></span></span></span></span> 是由隐变量 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.04398em;">z</span></span></span></span></span> 来决定的（相对样本<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">x</span></span></span></span></span> 来说，<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.04398em;">z</span></span></span></span></span> 通常不可观测），自然我们需要用期望极大算法（<a href="https://zg104.github.io/em">EM</a>），先关于隐变量的概率期望进行求解，在求极大更新参数，然后再反复迭代，最终使得对数似然函数收敛。</p>
<h4 id="variational-autoencoder-数学推导">Variational AutoEncoder 数学推导</h4>
<p>先回顾一下变分推断，在概率图模型里面，我们经常假设观测变量为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.07847em;">X</span></span></span></span></span>，隐变量为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.07153em;">Z</span></span></span></span></span>，图模型的结构是由 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.07153em;">Z</span></span></span></span></span> 生成 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.07847em;">X</span></span></span></span></span>。那么建立联合分布为：</p>
<p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>Z</mi><mo stretchy="false">)</mo><mo>=</mo><mi>p</mi><mo stretchy="false">(</mo><mi>X</mi><mi mathvariant="normal">∣</mi><mi>Z</mi><mo stretchy="false">)</mo><mi>p</mi><mo stretchy="false">(</mo><mi>Z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(X,Z) = p(X|Z)p(Z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.07153em;">Z</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.07847em;">X</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right: 0.07153em;">Z</span><span class="mclose">)</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.07153em;">Z</span><span class="mclose">)</span></span></span></span></span></span></p>
<p>为了计算观测变量 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.07847em;">X</span></span></span></span></span> 的对数似然 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ln</mi><mo>⁡</mo><mi>p</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\ln p(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mop">ln</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.07847em;">X</span><span class="mclose">)</span></span></span></span></span>，一般来说要将隐变量积分掉，即：</p>
<p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ln</mi><mo>⁡</mo><mi>p</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><mi>ln</mi><mo>⁡</mo><munder><mo>∑</mo><mi>Z</mi></munder><mi>p</mi><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>Z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\ln p(X) = \ln \sum_{Z}p(X,Z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mop">ln</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 2.34434em; vertical-align: -1.29434em;"></span><span class="mop">ln</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.05001em;"><span class="" style="top: -1.85566em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.07153em;">Z</span></span></span></span><span class="" style="top: -3.05001em;"><span class="pstrut" style="height: 3.05em;"></span><span class=""><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.29434em;"><span class=""></span></span></span></span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.07153em;">Z</span><span class="mclose">)</span></span></span></span></span></span></p>
<p>当隐变量是离散变量时，上述公式需要对所有可能的 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.07153em;">Z</span></span></span></span></span> 进行求和，当隐变量维度比较小时，可以计算，但维度非常高时就很难计算；当隐变量为连续变量时，如果假定 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.07153em;">Z</span></span></span></span></span> 为简单的高斯分布，并且条件分布 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>X</mi><mi mathvariant="normal">∣</mi><mi>Z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(X|Z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.07847em;">X</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right: 0.07153em;">Z</span><span class="mclose">)</span></span></span></span></span> 也满足一定条件（比如共轭分布）时，可以计算，但是绝大多数情况下，上述的积分操作是不可计算的。</p>
<p>所以为了优化最大似然，引入下面的 ELBO：<br>
<span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>ln</mi><mo>⁡</mo><mi>p</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>ln</mi><mo>⁡</mo><munder><mo>∑</mo><mi>Z</mi></munder><mi>p</mi><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>Z</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>ln</mi><mo>⁡</mo><mo fence="false">(</mo><munder><mo>∑</mo><mi>Z</mi></munder><mi>q</mi><mo stretchy="false">(</mo><mi>Z</mi><mo stretchy="false">)</mo><mfrac><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>Z</mi><mo stretchy="false">)</mo></mrow><mrow><mi>q</mi><mo stretchy="false">(</mo><mi>Z</mi><mo stretchy="false">)</mo></mrow></mfrac><mo fence="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>≥</mo><munder><mo>∑</mo><mi>Z</mi></munder><mi>q</mi><mo stretchy="false">(</mo><mi>Z</mi><mo stretchy="false">)</mo><mi>ln</mi><mo>⁡</mo><mfrac><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>Z</mi><mo stretchy="false">)</mo></mrow><mrow><mi>q</mi><mo stretchy="false">(</mo><mi>Z</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><munder><mo>∑</mo><mi>Z</mi></munder><mi>q</mi><mo stretchy="false">(</mo><mi>Z</mi><mo stretchy="false">)</mo><mi>ln</mi><mo>⁡</mo><mi>p</mi><mo stretchy="false">(</mo><mi>X</mi><mi mathvariant="normal">∣</mi><mi>Z</mi><mo stretchy="false">)</mo><mo>+</mo><munder><mo>∑</mo><mi>Z</mi></munder><mi>q</mi><mo stretchy="false">(</mo><mi>Z</mi><mo stretchy="false">)</mo><mi>ln</mi><mo>⁡</mo><mfrac><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>Z</mi><mo stretchy="false">)</mo></mrow><mrow><mi>q</mi><mo stretchy="false">(</mo><mi>Z</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
\ln p(X) &amp;= \ln \sum_{Z}p(X,Z) \\
&amp;= \ln \Bigg(\sum_{Z}q(Z) \frac{p(X,Z)}{q(Z)} \Bigg) \\
&amp; \geq \sum_{Z} q(Z) \ln \frac{p(X,Z)}{q(Z)}  \\
&amp;= \sum_{Z}q(Z) \ln p(X|Z) + \sum_{Z}q(Z) \ln \frac{p(Z)}{q(Z)}
\end{aligned}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 12.0313em; vertical-align: -5.76567em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 6.26567em;"><span class="" style="top: -8.96567em;"><span class="pstrut" style="height: 3.75em;"></span><span class="mord"><span class="mop">ln</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.07847em;">X</span><span class="mclose">)</span></span></span><span class="" style="top: -5.62133em;"><span class="pstrut" style="height: 3.75em;"></span><span class="mord"></span></span><span class="" style="top: -2.6em;"><span class="pstrut" style="height: 3.75em;"></span><span class="mord"></span></span><span class="" style="top: 0.421339em;"><span class="pstrut" style="height: 3.75em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 5.76567em;"><span class=""></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 6.26567em;"><span class="" style="top: -8.96567em;"><span class="pstrut" style="height: 3.75em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mop">ln</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.05001em;"><span class="" style="top: -1.85566em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.07153em;">Z</span></span></span></span><span class="" style="top: -3.05001em;"><span class="pstrut" style="height: 3.05em;"></span><span class=""><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.29434em;"><span class=""></span></span></span></span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.07153em;">Z</span><span class="mclose">)</span></span></span><span class="" style="top: -5.62133em;"><span class="pstrut" style="height: 3.75em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mop">ln</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="delimsizing size4">(</span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.05001em;"><span class="" style="top: -1.85566em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.07153em;">Z</span></span></span></span><span class="" style="top: -3.05001em;"><span class="pstrut" style="height: 3.05em;"></span><span class=""><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.29434em;"><span class=""></span></span></span></span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">q</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.07153em;">Z</span><span class="mclose">)</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.427em;"><span class="" style="top: -2.314em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">q</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.07153em;">Z</span><span class="mclose">)</span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.677em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.07153em;">Z</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.936em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="delimsizing size4">)</span></span></span></span><span class="" style="top: -2.6em;"><span class="pstrut" style="height: 3.75em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.05001em;"><span class="" style="top: -1.85566em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.07153em;">Z</span></span></span></span><span class="" style="top: -3.05001em;"><span class="pstrut" style="height: 3.05em;"></span><span class=""><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.29434em;"><span class=""></span></span></span></span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">q</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.07153em;">Z</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mop">ln</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.427em;"><span class="" style="top: -2.314em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">q</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.07153em;">Z</span><span class="mclose">)</span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.677em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.07153em;">Z</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.936em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span class="" style="top: 0.421339em;"><span class="pstrut" style="height: 3.75em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.05001em;"><span class="" style="top: -1.85566em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.07153em;">Z</span></span></span></span><span class="" style="top: -3.05001em;"><span class="pstrut" style="height: 3.05em;"></span><span class=""><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.29434em;"><span class=""></span></span></span></span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">q</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.07153em;">Z</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mop">ln</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.07847em;">X</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right: 0.07153em;">Z</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.05001em;"><span class="" style="top: -1.85566em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.07153em;">Z</span></span></span></span><span class="" style="top: -3.05001em;"><span class="pstrut" style="height: 3.05em;"></span><span class=""><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.29434em;"><span class=""></span></span></span></span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">q</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.07153em;">Z</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mop">ln</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.427em;"><span class="" style="top: -2.314em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">q</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.07153em;">Z</span><span class="mclose">)</span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.677em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.07153em;">Z</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.936em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 5.76567em;"><span class=""></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>上述公式的不等号支出根据 Jensen 不等式得到，最后得到 ELBO 下界：</p>
<p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ln</mi><mo>⁡</mo><mi>p</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>≥</mo><munder><mo>∑</mo><mi>Z</mi></munder><mi>q</mi><mo stretchy="false">(</mo><mi>Z</mi><mo stretchy="false">)</mo><mi>ln</mi><mo>⁡</mo><mi>p</mi><mo stretchy="false">(</mo><mi>X</mi><mi mathvariant="normal">∣</mi><mi>Z</mi><mo stretchy="false">)</mo><mo>+</mo><munder><mo>∑</mo><mi>Z</mi></munder><mi>q</mi><mo stretchy="false">(</mo><mi>Z</mi><mo stretchy="false">)</mo><mi>ln</mi><mo>⁡</mo><mfrac><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>Z</mi><mo stretchy="false">)</mo></mrow><mrow><mi>q</mi><mo stretchy="false">(</mo><mi>Z</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\ln p(X) \geq \sum_{Z}q(Z)\ln p(X|Z) +\sum_{Z}q(Z) \ln \frac{p(Z)}{q(Z)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mop">ln</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 2.34434em; vertical-align: -1.29434em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.05001em;"><span class="" style="top: -1.85566em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.07153em;">Z</span></span></span></span><span class="" style="top: -3.05001em;"><span class="pstrut" style="height: 3.05em;"></span><span class=""><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.29434em;"><span class=""></span></span></span></span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">q</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.07153em;">Z</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mop">ln</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.07847em;">X</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right: 0.07153em;">Z</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 2.72134em; vertical-align: -1.29434em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.05001em;"><span class="" style="top: -1.85566em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.07153em;">Z</span></span></span></span><span class="" style="top: -3.05001em;"><span class="pstrut" style="height: 3.05em;"></span><span class=""><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.29434em;"><span class=""></span></span></span></span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">q</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.07153em;">Z</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mop">ln</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.427em;"><span class="" style="top: -2.314em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">q</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.07153em;">Z</span><span class="mclose">)</span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.677em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.07153em;">Z</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.936em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></span></p>
<p>上式不等式右边就是 ELBO，最大化对数似然就变成了最大化 ELBO。ELBO 中的 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi><mo stretchy="false">(</mo><mi>Z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">q(Z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">q</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.07153em;">Z</span><span class="mclose">)</span></span></span></span></span> 是对隐变量 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.07153em;">Z</span></span></span></span></span> 引入的变分分布，用来近似真实的隐变量分布 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>Z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(Z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.07153em;">Z</span><span class="mclose">)</span></span></span></span></span>。所以 ELBO 由两项组成，第一项是给定隐变量时的条件分布的似然，第二项是变分分布和真实分布之间的 KL 距离。</p>
<img src="https://pic.downk.cc/item/5fe462393ffa7d37b3af6158.jpg" width="800">
<p>在 Mean-Field 变分推断中假设 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi><mo stretchy="false">(</mo><mi>Z</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo>∏</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>q</mi><mi>i</mi></msub><mo stretchy="false">(</mo><msub><mi>Z</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">q(Z) = \prod _{i=1}^{n}q_i(Z_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">q</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.07153em;">Z</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1.104em; vertical-align: -0.29971em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position: relative; top: -5e-06em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.804292em;"><span class="" style="top: -2.40029em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span class="" style="top: -3.2029em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.29971em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: -0.07153em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>，即假设 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.07153em;">Z</span></span></span></span></span> 由 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>Z</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>Z</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>⋯</mo> <mo separator="true">,</mo><msub><mi>Z</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">Z_1,Z_2,\cdots,Z_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.87777em; vertical-align: -0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.07153em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.07153em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: -0.07153em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 组成，并满足独立条件。由此可以简化计算，从而得到 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>q</mi><mi>i</mi></msub><mo stretchy="false">(</mo><msub><mi>Z</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">q_i(Z_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: -0.07153em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>。一般来说，Mean-Field 得到的结果类似于下面的形式</p>
<p align="center">
	  <img src="https://www.zhihu.com/equation?tex=q_j%28Z_j%29+%3D+%5Cfrac%7B%5Cexp%5Cleft%28+E_%7BZ+%5Csim+q_i%28Z_i%29%2C+i%5Cneq+j%7D%5Cleft%5B%5Cln+p%28X%2C+Z%29%5Cright%5D+%5Cright%29%7D%7B%5Cint+%5Cexp%5Cleft%28+E_%7BZ+%5Csim+q_i%28Z_i%29%2C+i%5Cneq+j%7D%5Cleft%5B%5Cln+p%28X%2C+Z%29%5Cright%5D+%5Cright%29dZ_j%7D+%5C%5C" width="700">
</p>
<hr>
<h3 id="font-id--23长短时记忆网络（lstm）font"><font id="23">长短时记忆网络（LSTM）</font></h3>
<h4 id="从rnn说起">0. 从RNN说起</h4>
<p>循环神经网络（Recurrent Neural Network，RNN）是一种用于处理序列数据的神经网络。相比一般的神经网络来说，他能够处理序列变化的数据。比如某个单词的意思会因为上文提到的内容不同而有不同的含义，RNN就能够很好地解决这类问题。</p>
<h4 id="普通rnn">1. 普通RNN</h4>
<p>先简单介绍一下一般的RNN。</p>
<p>其主要形式如下图所示（图片均来自台大李宏毅教授的PPT）：</p>
<p align="center">
	  <img src="https://pic4.zhimg.com/80/v2-f716c816d46792b867a6815c278f11cb_1440w.jpg" width="700">
</p>
<p>这里：</p>
<p><img src="https://www.zhihu.com/equation?tex=x" alt="[公式]">  为当前状态下数据的输入，  <img src="https://www.zhihu.com/equation?tex=h" alt="[公式]">  表示接收到的上一个节点的输入。</p>
<p><img src="https://www.zhihu.com/equation?tex=y" alt="[公式]">  为当前节点状态下的输出，而  <img src="https://www.zhihu.com/equation?tex=h%27" alt="[公式]">  为传递到下一个节点的输出。</p>
<p>通过上图的公式可以看到，输出  <strong>h’</strong>  与  <strong>x</strong>  和  <strong>h</strong>  的值都相关。</p>
<p>而  <strong>y</strong>  则常常使用  <strong>h’</strong> 投入到一个线性层（主要是进行维度映射）然后使用softmax进行分类得到需要的数据。</p>
<p>对这里的 <strong>y</strong> 如何通过 <strong>h’</strong> 计算得到往往看具体模型的使用方式。</p>
<p>通过序列形式的输入，我们能够得到如下形式的RNN。</p>
<p align="center">
	  <img src="https://pic2.zhimg.com/80/v2-71652d6a1eee9def631c18ea5e3c7605_1440w.jpg" width="700">
</p>
<hr>
<h4 id="lstm">2. LSTM</h4>
<h5 id="什么是lstm">2.1 什么是LSTM</h5>
<p>长短期记忆（Long short-term memory, LSTM）是一种特殊的RNN，主要是为了解决长序列训练过程中的梯度消失和梯度爆炸问题。简单来说，就是相比普通的 RNN，LSTM 能够在更长的序列中有更好的表现。</p>
<p>LSTM结构（图右）和普通RNN的主要输入输出区别如下所示。</p>
<p align="center">
	  <img src="https://pic4.zhimg.com/80/v2-e4f9851cad426dfe4ab1c76209546827_1440w.jpg" width="700">
</p>
<p>相比RNN只有一个传递状态  <img src="https://www.zhihu.com/equation?tex=h%5Et+" alt="[公式]">  ，LSTM有两个传输状态，一个  <img src="https://www.zhihu.com/equation?tex=c%5Et" alt="[公式]">  （cell state），和一个  <img src="https://www.zhihu.com/equation?tex=h%5Et" alt="[公式]">  （hidden state）。（Tips：RNN中的  <img src="https://www.zhihu.com/equation?tex=h%5Et" alt="[公式]">  对于LSTM中的  <img src="https://www.zhihu.com/equation?tex=c%5Et" alt="[公式]">  ）</p>
<p>其中对于传递下去的  <img src="https://www.zhihu.com/equation?tex=c%5Et" alt="[公式]">  改变得很慢，通常输出的  <img src="https://www.zhihu.com/equation?tex=c%5Et" alt="[公式]">  是上一个状态传过来的  <img src="https://www.zhihu.com/equation?tex=c%5E%7Bt-1%7D" alt="[公式]">  加上一些数值。</p>
<p>而  <img src="https://www.zhihu.com/equation?tex=h%5Et" alt="[公式]">  则在不同节点下往往会有很大的区别。</p>
<hr>
<h5 id="深入lstm结构">2.2 深入LSTM结构</h5>
<p>下面具体对 LSTM 的内部结构来进行剖析。</p>
<p>首先使用 LSTM 的当前输入  <img src="https://www.zhihu.com/equation?tex=x%5Et" alt="[公式]">  和上一个状态传递下来的  <img src="https://www.zhihu.com/equation?tex=h%5E%7Bt-1%7D" alt="[公式]">  拼接训练得到四个状态。</p>
<p align="center">
	  <img src="https://pic4.zhimg.com/80/v2-15c5eb554f843ec492579c6d87e1497b_1440w.jpg" width="400">
</p>
<p align="center">
	  <img src="https://pic1.zhimg.com/80/v2-d044fd0087e1df5d2a1089b441db9970_1440w.jpg" width="400">
</p>
<p>其中，  <img src="https://www.zhihu.com/equation?tex=z%5Ef+" alt="[公式]">  ，  <img src="https://www.zhihu.com/equation?tex=z%5Ei" alt="[公式]">  ，<img src="https://www.zhihu.com/equation?tex=z%5Eo" alt="[公式]">  是由拼接向量乘以权重矩阵之后，再通过一个  <img src="https://www.zhihu.com/equation?tex=sigmoid+" alt="[公式]">  激活函数转换成0到1之间的数值，来作为一种门控状态。而  <img src="https://www.zhihu.com/equation?tex=z" alt="[公式]">  则是将结果通过一个  <img src="https://www.zhihu.com/equation?tex=tanh" alt="[公式]">  激活函数将转换成-1到1之间的值（这里使用  <img src="https://www.zhihu.com/equation?tex=tanh" alt="[公式]">  是因为这里是将其做为输入数据，而不是门控信号）。</p>
<p><strong>下面开始进一步介绍这四个状态在LSTM内部的使用。（敲黑板）</strong></p>
<p align="center">
	  <img src="https://pic2.zhimg.com/80/v2-556c74f0e025a47fea05dc0f76ea775d_1440w.jpg" width="700">
</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Codot" alt="[公式]">  是Hadamard Product，也就是操作矩阵中对应的元素相乘，因此要求两个相乘矩阵是同型的。  <img src="https://www.zhihu.com/equation?tex=%5Coplus" alt="[公式]">  则代表进行矩阵加法。</p>
<p><font color="red">LSTM内部主要有三个阶段：</font></p>
<ol>
<li><strong>忘记阶段</strong>。这个阶段主要是对上一个节点传进来的输入进行<strong>选择性</strong>忘记。简单来说就是会 “忘记不重要的，记住重要的”。</li>
</ol>
<p>具体来说是通过计算得到的  <img src="https://www.zhihu.com/equation?tex=z%5Ef" alt="[公式]">  （<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span></span></span></span></span> 表示forget）来作为忘记门控，来控制上一个状态的  <img src="https://www.zhihu.com/equation?tex=c%5E%7Bt-1%7D" alt="[公式]">  哪些需要留哪些需要忘。</p>
<ol start="2">
<li><strong>选择记忆阶段</strong>。这个阶段将这个阶段的输入有选择性地进行“记忆”。主要是会对输入  <img src="https://www.zhihu.com/equation?tex=x%5Et" alt="[公式]">  进行选择记忆。哪些重要则着重记录下来，哪些不重要，则少记一些。当前的输入内容由前面计算得到的  <img src="https://www.zhihu.com/equation?tex=z+" alt="[公式]">  表示。而选择的门控信号则是由  <img src="https://www.zhihu.com/equation?tex=z%5Ei" alt="[公式]">  （i代表information）来进行控制。</li>
</ol>
<blockquote>
<p>将上面两步得到的结果相加，即可得到传输给下一个状态的  <img src="https://www.zhihu.com/equation?tex=c%5Et" alt="[公式]">  。也就是上图中的第一个公式。</p>
</blockquote>
<ol start="3">
<li><strong>输出阶段</strong>。这个阶段将决定哪些将会被当成当前状态的输出。主要是通过  <img src="https://www.zhihu.com/equation?tex=z%5Eo" alt="[公式]">  来进行控制的。并且还对上一阶段得到的  <img src="https://www.zhihu.com/equation?tex=c%5Eo" alt="[公式]">  进行了放缩（通过一个tanh激活函数进行变化）。</li>
</ol>
<p>与普通 RNN 类似，输出  <img src="https://www.zhihu.com/equation?tex=y%5Et" alt="[公式]">  往往最终也是通过  <img src="https://www.zhihu.com/equation?tex=h%5Et" alt="[公式]">  变化得到。</p>
<h4 id="总结">3. 总结</h4>
<p>以上，就是LSTM的内部结构。通过门控状态来控制传输状态，记住需要长时间记忆的，忘记不重要的信息；而不像普通的 RNN 那样只能够“呆萌”地仅有一种记忆叠加方式。对很多需要“长期记忆”的任务来说，尤其好用。</p>
<p>但也因为引入了很多内容，导致参数变多，也使得训练难度加大了很多。因此很多时候我们往往会使用效果和LSTM相当但参数更少的GRU来构建大训练量的模型。</p>
<hr>
<h2 id="第三部分-健康状况评估建模-1">第三部分 健康状况评估建模</h2>
<h3 id="健康状况评估概述">健康状况评估概述</h3>
<p>收益与传感器技术和数据存储技术的发展，我们能够更为有效地收集和存储海量的状态监控数据。而这些原始数据中往往含有着有关设备系统性能退化的关键特征。因此，为了充分挖掘系统失效信息，追踪系统退化过程，实时评估当前健康状况，往往需要借助数据挖掘、模式识别和信号处理等技术来对健康状况来建模。</p>
<h4 id="目标">目标</h4>
<p>我们目的是对设备系统的性能失效退化过程进行建模，简而言之，就是将多维传感器数据映射到一维的健康曲线上，从而实时、直观地反映系统性能退化程度和健康状况。事实上，大部分设备系统性能的退化状态都是无法直接监测的，有以下几个原因：</p>
<ol>
<li>设备生产运行过程中不允许频繁停机检查设备退化状态</li>
<li>对于某些故障来说，早期的损伤在没有专业设备帮助之下很难检测</li>
<li>复杂设备各个子系统相互耦合，内部故障机理很复杂，难以发现</li>
</ol>
<p>所以，针对以上问题，运用信号处理、数据融合或者及其学习等技术实现对性能退化郭晨估计按摩，构造能这是反映其健康状况的健康值曲线，才是可靠的有效措施。</p>
<h4 id="评价指标">评价指标</h4>
<p>为了定量评价所提出的<br>
健康状况评估建模方法的有效性，有专家引入了单调性、鲁棒性和趋势性三个常用性能评价指标。</p>
<ol>
<li>
<p>单调性</p>
<p>在实际工业场景中，往往设备退化的过程是不可逆的。所以为了更好地描述设备系统不可逆的性能退化失效过程，准确的健康值曲线应该是单调增加或单调减少。例如，某台设备健康值曲线 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.07847em;">X</span></span></span></span></span> 的单调性计算公式如下：</p>
<p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mi>o</mi><mi>n</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mrow><mi>K</mi><mo>−</mo><mn>1</mn></mrow></mfrac><mo fence="false">∣</mo><mi>N</mi><mi>o</mi><mi mathvariant="normal">.</mi><mi>o</mi><mi>f</mi><mfrac><mi>d</mi><mrow><mi>d</mi><mi>x</mi></mrow></mfrac><mo>&gt;</mo><mn>0</mn><mo>−</mo><mi>N</mi><mi>o</mi><mi mathvariant="normal">.</mi><mi>o</mi><mi>f</mi><mfrac><mi>d</mi><mrow><mi>d</mi><mi>x</mi></mrow></mfrac><mo>&lt;</mo><mn>0</mn><mo fence="false">∣</mo></mrow><annotation encoding="application/x-tex">Mon(X) = \frac{1}{K-1} \Big| No.of \frac{d}{dx} &gt; 0 - No.of \frac{d}{dx} &lt; 0 \Big|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10903em;">M</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 2.14077em; vertical-align: -0.76933em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.32144em;"><span class="" style="top: -2.314em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.07153em;">K</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord">1</span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.677em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.76933em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.16799em;"><span class="" style="top: -1.95599em;"><span class="pstrut" style="height: 2.606em;"></span><span class="delimsizinginner delim-size1"><span class="">∣</span></span></span><span class="" style="top: -2.56198em;"><span class="pstrut" style="height: 2.606em;"></span><span class="delimsizinginner delim-size1"><span class="">∣</span></span></span><span class="" style="top: -3.16798em;"><span class="pstrut" style="height: 2.606em;"></span><span class="delimsizinginner delim-size1"><span class="">∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.650015em;"><span class=""></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right: 0.10903em;">N</span><span class="mord mathdefault">o</span><span class="mord">.</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.37144em;"><span class="" style="top: -2.314em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.677em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.686em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 2.05744em; vertical-align: -0.686em;"></span><span class="mord mathdefault" style="margin-right: 0.10903em;">N</span><span class="mord mathdefault">o</span><span class="mord">.</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.37144em;"><span class="" style="top: -2.314em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.677em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.686em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1.818em; vertical-align: -0.650015em;"></span><span class="mord">0</span><span class="mord"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.16799em;"><span class="" style="top: -1.95599em;"><span class="pstrut" style="height: 2.606em;"></span><span class="delimsizinginner delim-size1"><span class="">∣</span></span></span><span class="" style="top: -2.56198em;"><span class="pstrut" style="height: 2.606em;"></span><span class="delimsizinginner delim-size1"><span class="">∣</span></span></span><span class="" style="top: -3.16798em;"><span class="pstrut" style="height: 2.606em;"></span><span class="delimsizinginner delim-size1"><span class="">∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.650015em;"><span class=""></span></span></span></span></span></span></span></span></span></span></span></p>
<p>其中，<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mo>=</mo><mo stretchy="false">{</mo><msub><mi>x</mi><mi>k</mi></msub><msub><mo stretchy="false">}</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn><mo>:</mo><mi>K</mi></mrow></msub></mrow><annotation encoding="application/x-tex">X = \{ x_k\}_{k=1:K}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.07847em;">X</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose"><span class="mclose">}</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span><span class="mrel mtight">:</span><span class="mord mathdefault mtight" style="margin-right: 0.07153em;">K</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 是系统的健康值序列；<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">x_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 表示设备在 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">t_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.76508em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 时刻的健康值，<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.07153em;">K</span></span></span></span></span> 值表示设备系统的健康值曲线长度；<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>d</mi><mrow><mi>d</mi><mi>x</mi></mrow></mfrac><mo>=</mo><msub><mi>x</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>−</mo><msub><mi>x</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">\frac{d}{dx} = x_{k+1} - x_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1.22511em; vertical-align: -0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.880108em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">x</span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.394em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.345em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.791661em; vertical-align: -0.208331em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.208331em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 表示序列中相邻健康值的微分；<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mi>o</mi><mi mathvariant="normal">.</mi><mi>o</mi><mi>f</mi><mfrac><mi>d</mi><mrow><mi>d</mi><mi>x</mi></mrow></mfrac><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">No.of \frac{d}{dx} &gt; 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1.22511em; vertical-align: -0.345em;"></span><span class="mord mathdefault" style="margin-right: 0.10903em;">N</span><span class="mord mathdefault">o</span><span class="mord">.</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.880108em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">x</span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.394em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.345em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">0</span></span></span></span></span> 和 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mi>o</mi><mi mathvariant="normal">.</mi><mi>o</mi><mi>f</mi><mfrac><mi>d</mi><mrow><mi>d</mi><mi>x</mi></mrow></mfrac><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">No.of \frac{d}{dx} &lt; 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1.22511em; vertical-align: -0.345em;"></span><span class="mord mathdefault" style="margin-right: 0.10903em;">N</span><span class="mord mathdefault">o</span><span class="mord">.</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.880108em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">x</span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.394em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.345em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">0</span></span></span></span></span> 分别代表微分为正和微分为负的计算值。<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mi>o</mi><mi>n</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Mon(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10903em;">M</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.07847em;">X</span><span class="mclose">)</span></span></span></span></span> 的取值范围在 0 ~ 1 之间，通常值越大意味着单调性越好。</p>
</li>
<li>
<p>鲁棒性</p>
<p>由于传感器测量噪声、退化过程的随机性和运行工况的</p>
</li>
</ol>
</div>
</body>

</html>
