<!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>
<script>
    document.addEventListener('DOMContentLoaded', function() {
        document.addEventListener('copy', function(event) {
            event.preventDefault();
            alert('Copying disabled!');
        });
    });
</script>

<style type='text/css'>html {overflow-x: initial !important;}:root { --bg-color:#ffffff; --text-color:#333333; --select-text-bg-color:#B5D6FC; --select-text-font-color:auto; --monospace:"Lucida Console",Consolas,"Courier",monospace; --title-bar-height:20px; }
.mac-os-11 { --title-bar-height:28px; }
html { font-size: 14px; background-color: var(--bg-color); color: var(--text-color); font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; }
h1, h2, h3, h4, h5 { white-space: pre-wrap; }
body { margin: 0px; padding: 0px; height: auto; inset: 0px; font-size: 1rem; line-height: 1.42857; overflow-x: hidden; background: inherit; tab-size: 4; }
iframe { margin: auto; }
a.url { word-break: break-all; }
a:active, a:hover { outline: 0px; }
.in-text-selection, ::selection { text-shadow: none; background: var(--select-text-bg-color); color: var(--select-text-font-color); }
#write { margin: 0px auto; height: auto; width: inherit; word-break: normal; overflow-wrap: break-word; position: relative; white-space: normal; overflow-x: visible; padding-top: 36px; }
#write.first-line-indent p { text-indent: 2em; }
#write.first-line-indent li p, #write.first-line-indent p * { text-indent: 0px; }
#write.first-line-indent li { margin-left: 2em; }
.for-image #write { padding-left: 8px; padding-right: 8px; }
body.typora-export { padding-left: 30px; padding-right: 30px; }
.typora-export .footnote-line, .typora-export li, .typora-export p { white-space: pre-wrap; }
.typora-export .task-list-item input { pointer-events: none; }
@media screen and (max-width: 500px) {
  body.typora-export { padding-left: 0px; padding-right: 0px; }
  #write { padding-left: 20px; padding-right: 20px; }
}
#write li > figure:last-child { margin-bottom: 0.5rem; }
#write ol, #write ul { position: relative; }
img { max-width: 100%; vertical-align: middle; image-orientation: from-image; }
button, input, select, textarea { color: inherit; font: inherit; }
input[type="checkbox"], input[type="radio"] { line-height: normal; padding: 0px; }
*, ::after, ::before { box-sizing: border-box; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p, #write pre { width: inherit; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p { position: relative; }
p { line-height: inherit; }
h1, h2, h3, h4, h5, h6 { break-after: avoid-page; break-inside: avoid; orphans: 4; }
p { orphans: 4; }
h1 { font-size: 2rem; }
h2 { font-size: 1.8rem; }
h3 { font-size: 1.6rem; }
h4 { font-size: 1.4rem; }
h5 { font-size: 1.2rem; }
h6 { font-size: 1rem; }
.md-math-block, .md-rawblock, h1, h2, h3, h4, h5, h6, p { margin-top: 1rem; margin-bottom: 1rem; }
.hidden { display: none; }
.md-blockmeta { color: rgb(204, 204, 204); font-weight: 700; font-style: italic; }
a { cursor: pointer; }
sup.md-footnote { padding: 2px 4px; background-color: rgba(238, 238, 238, 0.7); color: rgb(85, 85, 85); border-radius: 4px; cursor: pointer; }
sup.md-footnote a, sup.md-footnote a:hover { color: inherit; text-transform: inherit; text-decoration: inherit; }
#write input[type="checkbox"] { cursor: pointer; width: inherit; height: inherit; }
figure { overflow-x: auto; margin: 1.2em 0px; max-width: calc(100% + 16px); padding: 0px; }
figure > table { margin: 0px; }
thead, tr { break-inside: avoid; break-after: auto; }
thead { display: table-header-group; }
table { border-collapse: collapse; border-spacing: 0px; width: 100%; overflow: auto; break-inside: auto; text-align: left; }
table.md-table td { min-width: 32px; }
.CodeMirror-gutters { border-right: 0px; background-color: inherit; }
.CodeMirror-linenumber { user-select: none; }
.CodeMirror { text-align: left; }
.CodeMirror-placeholder { opacity: 0.3; }
.CodeMirror pre { padding: 0px 4px; }
.CodeMirror-lines { padding: 0px; }
div.hr:focus { cursor: none; }
#write pre { white-space: pre-wrap; }
#write.fences-no-line-wrapping pre { white-space: pre; }
#write pre.ty-contain-cm { white-space: normal; }
.CodeMirror-gutters { margin-right: 4px; }
.md-fences { font-size: 0.9rem; display: block; break-inside: avoid; text-align: left; overflow: visible; white-space: pre; background: inherit; position: relative !important; }
.md-fences-adv-panel { width: 100%; margin-top: 10px; text-align: center; padding-top: 0px; padding-bottom: 8px; overflow-x: auto; }
#write .md-fences.mock-cm { white-space: pre-wrap; }
.md-fences.md-fences-with-lineno { padding-left: 0px; }
#write.fences-no-line-wrapping .md-fences.mock-cm { white-space: pre; overflow-x: auto; }
.md-fences.mock-cm.md-fences-with-lineno { padding-left: 8px; }
.CodeMirror-line, twitterwidget { break-inside: avoid; }
svg { break-inside: avoid; }
.footnotes { opacity: 0.8; font-size: 0.9rem; margin-top: 1em; margin-bottom: 1em; }
.footnotes + .footnotes { margin-top: 0px; }
.md-reset { margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: top; background: 0px 0px; text-decoration: none; text-shadow: none; float: none; position: static; width: auto; height: auto; white-space: nowrap; cursor: inherit; -webkit-tap-highlight-color: transparent; line-height: normal; font-weight: 400; text-align: left; box-sizing: content-box; direction: ltr; }
li div { padding-top: 0px; }
blockquote { margin: 1rem 0px; }
li .mathjax-block, li p { margin: 0.5rem 0px; }
li blockquote { margin: 1rem 0px; }
li { margin: 0px; position: relative; }
blockquote > :last-child { margin-bottom: 0px; }
blockquote > :first-child, li > :first-child { margin-top: 0px; }
.footnotes-area { color: rgb(136, 136, 136); margin-top: 0.714rem; padding-bottom: 0.143rem; white-space: normal; }
#write .footnote-line { white-space: pre-wrap; }
@media print {
  body, html { border: 1px solid transparent; height: 99%; break-after: avoid; break-before: avoid; font-variant-ligatures: no-common-ligatures; }
  #write { margin-top: 0px; border-color: transparent !important; padding-top: 0px !important; padding-bottom: 0px !important; }
  .typora-export * { -webkit-print-color-adjust: exact; }
  .typora-export #write { break-after: avoid; }
  .typora-export #write::after { height: 0px; }
  .is-mac table { break-inside: avoid; }
  #write > p:nth-child(1) { margin-top: 0px; }
  .typora-export-show-outline .typora-export-sidebar { display: none; }
  figure { overflow-x: visible; }
}
.footnote-line { margin-top: 0.714em; font-size: 0.7em; }
a img, img a { cursor: pointer; }
pre.md-meta-block { font-size: 0.8rem; min-height: 0.8rem; white-space: pre-wrap; background: rgb(204, 204, 204); display: block; overflow-x: hidden; }
p > .md-image:only-child:not(.md-img-error) img, p > img:only-child { display: block; margin: auto; }
#write.first-line-indent p > .md-image:only-child:not(.md-img-error) img { left: -2em; position: relative; }
p > .md-image:only-child { display: inline-block; width: 100%; }
#write .MathJax_Display { margin: 0.8em 0px 0px; }
.md-math-block { width: 100%; }
.md-math-block:not(:empty)::after { display: none; }
.MathJax_ref { fill: currentcolor; }
[contenteditable="true"]:active, [contenteditable="true"]:focus, [contenteditable="false"]:active, [contenteditable="false"]:focus { outline: 0px; box-shadow: none; }
.md-task-list-item { position: relative; list-style-type: none; }
.task-list-item.md-task-list-item { padding-left: 0px; }
.md-task-list-item > input { position: absolute; top: 0px; left: 0px; margin-left: -1.2em; margin-top: calc(1em - 10px); border: none; }
.math { font-size: 1rem; }
.md-toc { min-height: 3.58rem; position: relative; font-size: 0.9rem; border-radius: 10px; }
.md-toc-content { position: relative; margin-left: 0px; }
.md-toc-content::after, .md-toc::after { display: none; }
.md-toc-item { display: block; color: rgb(65, 131, 196); }
.md-toc-item a { text-decoration: none; }
.md-toc-inner:hover { text-decoration: underline; }
.md-toc-inner { display: inline-block; cursor: pointer; }
.md-toc-h1 .md-toc-inner { margin-left: 0px; font-weight: 700; }
.md-toc-h2 .md-toc-inner { margin-left: 2em; }
.md-toc-h3 .md-toc-inner { margin-left: 4em; }
.md-toc-h4 .md-toc-inner { margin-left: 6em; }
.md-toc-h5 .md-toc-inner { margin-left: 8em; }
.md-toc-h6 .md-toc-inner { margin-left: 10em; }
@media screen and (max-width: 48em) {
  .md-toc-h3 .md-toc-inner { margin-left: 3.5em; }
  .md-toc-h4 .md-toc-inner { margin-left: 5em; }
  .md-toc-h5 .md-toc-inner { margin-left: 6.5em; }
  .md-toc-h6 .md-toc-inner { margin-left: 8em; }
}
a.md-toc-inner { font-size: inherit; font-style: inherit; font-weight: inherit; line-height: inherit; }
.footnote-line a:not(.reversefootnote) { color: inherit; }
.reversefootnote { font-family: ui-monospace, sans-serif; }
.md-attr { display: none; }
.md-fn-count::after { content: "."; }
code, pre, samp, tt { font-family: var(--monospace); }
kbd { margin: 0px 0.1em; padding: 0.1em 0.6em; font-size: 0.8em; color: rgb(36, 39, 41); background: rgb(255, 255, 255); border: 1px solid rgb(173, 179, 185); border-radius: 3px; box-shadow: rgba(12, 13, 14, 0.2) 0px 1px 0px, rgb(255, 255, 255) 0px 0px 0px 2px inset; white-space: nowrap; vertical-align: middle; }
.md-comment { color: rgb(162, 127, 3); opacity: 0.6; font-family: var(--monospace); }
code { text-align: left; vertical-align: initial; }
a.md-print-anchor { white-space: pre !important; border-width: initial !important; border-style: none !important; border-color: initial !important; display: inline-block !important; position: absolute !important; width: 1px !important; right: 0px !important; outline: 0px !important; background: 0px 0px !important; text-decoration: initial !important; text-shadow: initial !important; }
.os-windows.monocolor-emoji .md-emoji { font-family: "Segoe UI Symbol", sans-serif; }
.md-diagram-panel > svg { max-width: 100%; }
[lang="flow"] svg, [lang="mermaid"] svg { max-width: 100%; height: auto; }
[lang="mermaid"] .node text { font-size: 1rem; }
table tr th { border-bottom: 0px; }
video { max-width: 100%; display: block; margin: 0px auto; }
iframe { max-width: 100%; width: 100%; border: none; }
.highlight td, .highlight tr { border: 0px; }
mark { background: rgb(255, 255, 0); color: rgb(0, 0, 0); }
.md-html-inline .md-plain, .md-html-inline strong, mark .md-inline-math, mark strong { color: inherit; }
.md-expand mark .md-meta { opacity: 0.3 !important; }
mark .md-meta { color: rgb(0, 0, 0); }
@media print {
  .typora-export h1, .typora-export h2, .typora-export h3, .typora-export h4, .typora-export h5, .typora-export h6 { break-inside: avoid; }
}
.md-diagram-panel .messageText { stroke: none !important; }
.md-diagram-panel .start-state { fill: var(--node-fill); }
.md-diagram-panel .edgeLabel rect { opacity: 1 !important; }
.md-fences.md-fences-math { font-size: 1em; }
.md-fences-advanced:not(.md-focus) { padding: 0px; white-space: nowrap; border: 0px; }
.md-fences-advanced:not(.md-focus) { background: inherit; }
.typora-export-show-outline .typora-export-content { max-width: 1440px; margin: auto; display: flex; flex-direction: row; }
.typora-export-sidebar { width: 300px; font-size: 0.8rem; margin-top: 80px; margin-right: 18px; }
.typora-export-show-outline #write { --webkit-flex:2; flex: 2 1 0%; }
.typora-export-sidebar .outline-content { position: fixed; top: 0px; max-height: 100%; overflow: hidden auto; padding-bottom: 30px; padding-top: 60px; width: 300px; }
@media screen and (max-width: 1024px) {
  .typora-export-sidebar, .typora-export-sidebar .outline-content { width: 240px; }
}
@media screen and (max-width: 800px) {
  .typora-export-sidebar { display: none; }
}
.outline-content li, .outline-content ul { margin-left: 0px; margin-right: 0px; padding-left: 0px; padding-right: 0px; list-style: none; overflow-wrap: anywhere; }
.outline-content ul { margin-top: 0px; margin-bottom: 0px; }
.outline-content strong { font-weight: 400; }
.outline-expander { width: 1rem; height: 1.42857rem; position: relative; display: table-cell; vertical-align: middle; cursor: pointer; padding-left: 4px; }
.outline-expander::before { content: ""; position: relative; font-family: Ionicons; display: inline-block; font-size: 8px; vertical-align: middle; }
.outline-item { padding-top: 3px; padding-bottom: 3px; cursor: pointer; }
.outline-expander:hover::before { content: ""; }
.outline-h1 > .outline-item { padding-left: 0px; }
.outline-h2 > .outline-item { padding-left: 1em; }
.outline-h3 > .outline-item { padding-left: 2em; }
.outline-h4 > .outline-item { padding-left: 3em; }
.outline-h5 > .outline-item { padding-left: 4em; }
.outline-h6 > .outline-item { padding-left: 5em; }
.outline-label { cursor: pointer; display: table-cell; vertical-align: middle; text-decoration: none; color: inherit; }
.outline-label:hover { text-decoration: underline; }
.outline-item:hover { border-color: rgb(245, 245, 245); background-color: var(--item-hover-bg-color); }
.outline-item:hover { margin-left: -28px; margin-right: -28px; border-left: 28px solid transparent; border-right: 28px solid transparent; }
.outline-item-single .outline-expander::before, .outline-item-single .outline-expander:hover::before { display: none; }
.outline-item-open > .outline-item > .outline-expander::before { content: ""; }
.outline-children { display: none; }
.info-panel-tab-wrapper { display: none; }
.outline-item-open > .outline-children { display: block; }
.typora-export .outline-item { padding-top: 1px; padding-bottom: 1px; }
.typora-export .outline-item:hover { margin-right: -8px; border-right: 8px solid transparent; }
.typora-export .outline-expander::before { content: "+"; font-family: inherit; top: -1px; }
.typora-export .outline-expander:hover::before, .typora-export .outline-item-open > .outline-item > .outline-expander::before { content: "−"; }
.typora-export-collapse-outline .outline-children { display: none; }
.typora-export-collapse-outline .outline-item-open > .outline-children, .typora-export-no-collapse-outline .outline-children { display: block; }
.typora-export-no-collapse-outline .outline-expander::before { content: "" !important; }
.typora-export-show-outline .outline-item-active > .outline-item .outline-label { font-weight: 700; }
.md-inline-math-container mjx-container { zoom: 0.95; }
mjx-container { break-inside: avoid; }


.CodeMirror { height: auto; }
.CodeMirror.cm-s-inner { background: inherit; }
.CodeMirror-scroll { overflow: auto hidden; z-index: 3; }
.CodeMirror-gutter-filler, .CodeMirror-scrollbar-filler { background-color: rgb(255, 255, 255); }
.CodeMirror-gutters { border-right: 1px solid rgb(221, 221, 221); background: inherit; white-space: nowrap; }
.CodeMirror-linenumber { padding: 0px 3px 0px 5px; text-align: right; color: rgb(153, 153, 153); }
.cm-s-inner .cm-keyword { color: rgb(119, 0, 136); }
.cm-s-inner .cm-atom, .cm-s-inner.cm-atom { color: rgb(34, 17, 153); }
.cm-s-inner .cm-number { color: rgb(17, 102, 68); }
.cm-s-inner .cm-def { color: rgb(0, 0, 255); }
.cm-s-inner .cm-variable { color: rgb(0, 0, 0); }
.cm-s-inner .cm-variable-2 { color: rgb(0, 85, 170); }
.cm-s-inner .cm-variable-3 { color: rgb(0, 136, 85); }
.cm-s-inner .cm-string { color: rgb(170, 17, 17); }
.cm-s-inner .cm-property { color: rgb(0, 0, 0); }
.cm-s-inner .cm-operator { color: rgb(152, 26, 26); }
.cm-s-inner .cm-comment, .cm-s-inner.cm-comment { color: rgb(170, 85, 0); }
.cm-s-inner .cm-string-2 { color: rgb(255, 85, 0); }
.cm-s-inner .cm-meta { color: rgb(85, 85, 85); }
.cm-s-inner .cm-qualifier { color: rgb(85, 85, 85); }
.cm-s-inner .cm-builtin { color: rgb(51, 0, 170); }
.cm-s-inner .cm-bracket { color: rgb(153, 153, 119); }
.cm-s-inner .cm-tag { color: rgb(17, 119, 0); }
.cm-s-inner .cm-attribute { color: rgb(0, 0, 204); }
.cm-s-inner .cm-header, .cm-s-inner.cm-header { color: rgb(0, 0, 255); }
.cm-s-inner .cm-quote, .cm-s-inner.cm-quote { color: rgb(0, 153, 0); }
.cm-s-inner .cm-hr, .cm-s-inner.cm-hr { color: rgb(153, 153, 153); }
.cm-s-inner .cm-link, .cm-s-inner.cm-link { color: rgb(0, 0, 204); }
.cm-negative { color: rgb(221, 68, 68); }
.cm-positive { color: rgb(34, 153, 34); }
.cm-header, .cm-strong { font-weight: 700; }
.cm-del { text-decoration: line-through; }
.cm-em { font-style: italic; }
.cm-link { text-decoration: underline; }
.cm-error { color: red; }
.cm-invalidchar { color: red; }
.cm-constant { color: rgb(38, 139, 210); }
.cm-defined { color: rgb(181, 137, 0); }
div.CodeMirror span.CodeMirror-matchingbracket { color: rgb(0, 255, 0); }
div.CodeMirror span.CodeMirror-nonmatchingbracket { color: rgb(255, 34, 34); }
.cm-s-inner .CodeMirror-activeline-background { background: inherit; }
.CodeMirror { position: relative; overflow: hidden; }
.CodeMirror-scroll { height: 100%; outline: 0px; position: relative; box-sizing: content-box; background: inherit; }
.CodeMirror-sizer { position: relative; }
.CodeMirror-gutter-filler, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-vscrollbar { position: absolute; z-index: 6; display: none; outline: 0px; }
.CodeMirror-vscrollbar { right: 0px; top: 0px; overflow: hidden; }
.CodeMirror-hscrollbar { bottom: 0px; left: 0px; overflow: auto hidden; }
.CodeMirror-scrollbar-filler { right: 0px; bottom: 0px; }
.CodeMirror-gutter-filler { left: 0px; bottom: 0px; }
.CodeMirror-gutters { position: absolute; left: 0px; top: 0px; padding-bottom: 10px; z-index: 3; overflow-y: hidden; }
.CodeMirror-gutter { white-space: normal; height: 100%; box-sizing: content-box; padding-bottom: 30px; margin-bottom: -32px; display: inline-block; }
.CodeMirror-gutter-wrapper { position: absolute; z-index: 4; background: 0px 0px !important; border: none !important; }
.CodeMirror-gutter-background { position: absolute; top: 0px; bottom: 0px; z-index: 4; }
.CodeMirror-gutter-elt { position: absolute; cursor: default; z-index: 4; }
.CodeMirror-lines { cursor: text; }
.CodeMirror pre { border-radius: 0px; border-width: 0px; background: 0px 0px; font-family: inherit; font-size: inherit; margin: 0px; white-space: pre; overflow-wrap: normal; color: inherit; z-index: 2; position: relative; overflow: visible; }
.CodeMirror-wrap pre { overflow-wrap: break-word; white-space: pre-wrap; word-break: normal; }
.CodeMirror-code pre { border-right: 30px solid transparent; width: fit-content; }
.CodeMirror-wrap .CodeMirror-code pre { border-right: none; width: auto; }
.CodeMirror-linebackground { position: absolute; inset: 0px; z-index: 0; }
.CodeMirror-linewidget { position: relative; z-index: 2; overflow: auto; }
.CodeMirror-wrap .CodeMirror-scroll { overflow-x: hidden; }
.CodeMirror-measure { position: absolute; width: 100%; height: 0px; overflow: hidden; visibility: hidden; }
.CodeMirror-measure pre { position: static; }
.CodeMirror div.CodeMirror-cursor { position: absolute; visibility: hidden; border-right: none; width: 0px; }
.CodeMirror div.CodeMirror-cursor { visibility: hidden; }
.CodeMirror-focused div.CodeMirror-cursor { visibility: inherit; }
.cm-searching { background: rgba(255, 255, 0, 0.4); }
span.cm-underlined { text-decoration: underline; }
span.cm-strikethrough { text-decoration: line-through; }
.cm-tw-syntaxerror { color: rgb(255, 255, 255); background-color: rgb(153, 0, 0); }
.cm-tw-deleted { text-decoration: line-through; }
.cm-tw-header5 { font-weight: 700; }
.cm-tw-listitem:first-child { padding-left: 10px; }
.cm-tw-box { border-style: solid; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-color: inherit; border-top-width: 0px !important; }
.cm-tw-underline { text-decoration: underline; }
@media print {
  .CodeMirror div.CodeMirror-cursor { visibility: hidden; }
}


html {
	font-size: 19px;
}

html, body {
	margin: auto;
	background: #fefefe;
	-webkit-font-smoothing: antialiased;
}
body {
	font-family: "Vollkorn", Palatino, Times;
	color: #333;
	line-height: 1.4;
	text-align: justify;
}

#write {
	max-width: 960px;
	margin: 0 auto;
	margin-bottom: 2em;
	line-height: 1.53;
	padding-top: 40px;
}

@media only screen and (min-width: 1400px) {
	#write {
		max-width: 1100px;
	}
}

@media print {
	html {
		font-size: 13px;
	}
}

/* Typography
-------------------------------------------------------- */

#write>h1:first-child,
h1 {
	margin-top: 1.6em;
	font-weight: normal;
}

h1 {
	font-size:3em;
}

h2 {
	margin-top:2em;
	font-weight: normal;
}

h3 {
	font-weight: normal;
	font-style: italic;
	margin-top: 3em;
}

h1, 
h2, 
h3{
	text-align: center;
}

h2:after{
	border-bottom: 1px solid #2f2f2f;
    content: '';
    width: 100px;
    display: block;
    margin: 0 auto;
    height: 1px;
}

h1+h2, h2+h3 {
	margin-top: 0.83em;
}

p,
.mathjax-block {
	margin-top: 0;
	-webkit-hypens: auto;
	-moz-hypens: auto;
	hyphens: auto;
}
ul {
	list-style: square;
	padding-left: 1.2em;
}
ol {
	padding-left: 1.2em;
}
blockquote {
	margin-left: 1em;
	padding-left: 1em;
	border-left: 1px solid #ddd;
}
code,
pre {
	font-family: "Consolas", "Menlo", "Monaco", monospace, serif;
	font-size: .9em;
	background: white;
}
.md-fences{
	margin-left: 1em;
	padding-left: 1em;
	border: 1px solid #ddd;
	padding-bottom: 8px;
	padding-top: 6px;
	margin-bottom: 1.5em;
}

a {
	color: #2484c1;
	text-decoration: none;
}
a:hover {
	text-decoration: underline;
}
a img {
	border: none;
}
h1 a,
h1 a:hover {
	color: #333;
	text-decoration: none;
}
hr {
	color: #ddd;
	height: 1px;
	margin: 2em 0;
	border-top: solid 1px #ddd;
	border-bottom: none;
	border-left: 0;
	border-right: 0;
}
.ty-table-edit {
	background: #ededed;
    padding-top: 4px;
}
table {
	margin-bottom: 1.333333rem
}
table th,
table td {
	padding: 8px;
	line-height: 1.333333rem;
	vertical-align: top;
	border-top: 1px solid #ddd
}
table th {
	font-weight: bold
}
table thead th {
	vertical-align: bottom
}
table caption+thead tr:first-child th,
table caption+thead tr:first-child td,
table colgroup+thead tr:first-child th,
table colgroup+thead tr:first-child td,
table thead:first-child tr:first-child th,
table thead:first-child tr:first-child td {
	border-top: 0
}
table tbody+tbody {
	border-top: 2px solid #ddd
}

.task-list{
	padding:0;
}

.md-task-list-item {
	padding-left: 1.6rem;
}

.md-task-list-item > input:before {
	content: '\221A';
	display: inline-block;
	width: 1.33333333rem;
  	height: 1.6rem;
	vertical-align: middle;
	text-align: center;
	color: #ddd;
	background-color: #fefefe;
}

.md-task-list-item > input:checked:before,
.md-task-list-item > input[checked]:before{
	color: inherit;
}
.md-tag {
	color: inherit;
	font: inherit;
}
#write pre.md-meta-block {
	min-height: 35px;
	padding: 0.5em 1em;
}
#write pre.md-meta-block {
	white-space: pre;
	background: #f8f8f8;
	border: 0px;
	color: #999;
	
	width: 100vw;
	max-width: calc(100% + 60px);
	margin-left: -30px;
	border-left: 30px #f8f8f8 solid;
	border-right: 30px #f8f8f8 solid;

	margin-bottom: 2em;
	margin-top: -1.3333333333333rem;
	padding-top: 26px;
	padding-bottom: 10px;
	line-height: 1.8em;
	font-size: 0.9em;
	font-size: 0.76em;
	padding-left: 0;
}
.md-img-error.md-image>.md-meta{
	vertical-align: bottom;
}
#write>h5.md-focus:before {
	top: 2px;
}

.md-toc {
	margin-top: 40px;
}

.md-toc-content {
	padding-bottom: 20px;
}

.outline-expander:before {
	color: inherit;
	font-size: 14px;
	top: auto;
	content: "\f0da";
	font-family: FontAwesome;
}

.outline-expander:hover:before,
.outline-item-open>.outline-item>.outline-expander:before {
  	content: "\f0d7";
}

/** source code mode */
#typora-source {
	font-family: Courier, monospace;
    color: #6A6A6A;
}

.html-for-mac #typora-sidebar {
    -webkit-box-shadow: 0 6px 12px rgba(0, 0, 0, .175);
    box-shadow: 0 6px 12px rgba(0, 0, 0, .175);
}

.cm-s-typora-default .cm-header, 
.cm-s-typora-default .cm-property,
.CodeMirror.cm-s-typora-default div.CodeMirror-cursor {
	color: #428bca;
}

.cm-s-typora-default .cm-atom, .cm-s-typora-default .cm-number {
	color: #777777;
}

.typora-node .file-list-item-parent-loc, 
.typora-node .file-list-item-time, 
.typora-node .file-list-item-summary {
	font-family: arial, sans-serif;
}

.md-task-list-item>input {
    margin-left: -1.3em;
    margin-top: calc(1rem - 12px);
}

.md-mathjax-midline {
	background: #fafafa;
}

.md-fences .code-tooltip {
	bottom: -2em !important;
}

.dropdown-menu .divider {
	border-color: #e5e5e5;
}


</style><title>XGBoost</title>
</head>
<body class='typora-export os-windows'><div class='typora-export-content'>
<div id='write'  class=''><h2 id='xgboost'><span>XGBoost</span></h2><p><img src="https://repository-images.githubusercontent.com/468816340/79337a1e-f158-4168-9ea3-3f81b4a11d23" alt="xgboost-classifier · GitHub Topics · GitHub" style="zoom:67%;" /></p><div class='md-toc' mdtype='toc'><p class="md-toc-content" role="list"><span role="listitem" class="md-toc-item md-toc-h2" data-ref="n0"><a class="md-toc-inner" href="#xgboost">XGBoost</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n485"><a class="md-toc-inner" href="#summary">Summary</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n9"><a class="md-toc-inner" href="#key-takeaways">Key Takeaways</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n34"><a class="md-toc-inner" href="#interview-questions">Interview Questions</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n41"><a class="md-toc-inner" href="#what-is-xgboost-and-how-does-it-differ-from-traditional-gradient-boosting-algorithms">What is XGBoost, and how does it differ from traditional gradient boosting algorithms?</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n489"><a class="md-toc-inner" href="#key-differences-between-xgboost-and-gbdt">Key differences between XGBoost and GBDT</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n515"><a class="md-toc-inner" href="#why-does-xgboost-use-second-order-taylor-expansion">Why does XGBoost use second-order Taylor expansion?</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n546"><a class="md-toc-inner" href="#how-does-xgboost-handle-imbalanced-datasets">How does XGBoost handle imbalanced datasets?</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n530"><a class="md-toc-inner" href="#in-what-scenarios-is-logistic-regression-lr-preferred-over-gradient-boosting-decision-trees-gbdt">In what scenarios is Logistic Regression (LR) preferred over Gradient Boosting Decision Trees (GBDT)?</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n558"><a class="md-toc-inner" href="#why-can-xgboost-be-trained-in-parallel-how-is-it-trained">Why can XGBoost be trained in parallel? How is it trained?</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n43"><a class="md-toc-inner" href="#explain-the-concept-of-boosting-and-how-xgboost-utilizes-it-for-improved-predictive-modeling">Explain the concept of boosting and how XGBoost utilizes it for improved predictive modeling.</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n45"><a class="md-toc-inner" href="#what-are-the-advantages-of-using-xgboost-over-other-machine-learning-algorithms">What are the advantages of using XGBoost over other machine learning algorithms?</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n47"><a class="md-toc-inner" href="#what-regularization-techniques-are-employed-in-xgboost-to-prevent-overfitting">What regularization techniques are employed in XGBoost to prevent overfitting?</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n49"><a class="md-toc-inner" href="#how-does-xgboost-handle-missing-values-in-the-dataset">How does XGBoost handle missing values in the dataset?</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n51"><a class="md-toc-inner" href="#can-you-briefly-explain-the-objective-functions-available-in-xgboost-for-regression-and-classification-tasks">Can you briefly explain the objective functions available in XGBoost for regression and classification tasks?</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n53"><a class="md-toc-inner" href="#what-is-the-role-of-the-learning-rate-eta-parameter-in-xgboost-and-how-does-it-affect-the-training-process">What is the role of the learning rate (eta) parameter in XGBoost, and how does it affect the training process?</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n55"><a class="md-toc-inner" href="#describe-the-process-of-early-stopping-in-xgboost-and-its-purpose">Describe the process of early stopping in XGBoost and its purpose.</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n57"><a class="md-toc-inner" href="#how-does-xgboost-handle-categorical-variables-in-the-dataset">How does XGBoost handle categorical variables in the dataset?</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n59"><a class="md-toc-inner" href="#what-are-the-key-hyperparameters-in-xgboost-and-how-do-they-impact-the-models-performance">What are the key hyperparameters in XGBoost, and how do they impact the model's performance?</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n61"><a class="md-toc-inner" href="#how-can-you-assess-the-importance-of-features-in-an-xgboost-model">How can you assess the importance of features in an XGBoost model?</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n63"><a class="md-toc-inner" href="#what-is-the-difference-between-xgboosts-tree-based-and-linear-base-learners">What is the difference between XGBoost's tree-based and linear base learners?</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n65"><a class="md-toc-inner" href="#explain-the-concept-of-ensemble-learning-and-how-it-is-utilized-in-xgboost">Explain the concept of ensemble learning and how it is utilized in XGBoost.</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n67"><a class="md-toc-inner" href="#how-can-you-tune-the-hyperparameters-of-an-xgboost-model-to-improve-its-performance">How can you tune the hyperparameters of an XGBoost model to improve its performance?</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n69"><a class="md-toc-inner" href="#can-you-compare-xgboost-with-random-forest-and-highlight-their-differences-and-similarities">Can you compare XGBoost with Random Forest and highlight their differences and similarities?</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n73"><a class="md-toc-inner" href="#how-can-you-interpret-the-output-of-an-xgboost-model-in-terms-of-feature-importance">How can you interpret the output of an XGBoost model in terms of feature importance?</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n75"><a class="md-toc-inner" href="#are-there-any-specific-scenarios-or-types-of-data-where-xgboost-is-particularly-effective-or-not-suitable">Are there any specific scenarios or types of data where XGBoost is particularly effective or not suitable?</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n79"><a class="md-toc-inner" href="#what-are-some-practical-considerations-for-implementing-xgboost-in-a-production-environment">What are some practical considerations for implementing XGBoost in a production environment?</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n575"><a class="md-toc-inner" href="#what-are-the-differences-between-xgboost-and-lightgbm">What are the differences between XGBoost and LightGBM?</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n590"><a class="md-toc-inner" href="#python-implement">Python Implement</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n602"><a class="md-toc-inner" href="#using-sklearn">Using Sklearn</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n600"><a class="md-toc-inner" href="#how-to-train-xgboost-model-with-pyspark">How to Train XGBoost Model With PySpark</a></span></p></div><p>&nbsp;</p><h3 id='summary'><span>Summary</span></h3><p><span>XGBoost is a powerful gradient boosting algorithm with features including high performance, scalability, support for various loss functions and tree types, automatic handling of missing values, feature selection, and importance evaluation.</span></p><iframe width="853" height="480" src="https://www.youtube.com/embed/OtD8wVaFm6E" title="XGBoost Part 1 (of 4): Regression" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe><h3 id='key-takeaways'><span>Key Takeaways</span></h3><ol><li><p><span>XGBoost (eXtreme Gradient Boosting) is a popular and powerful machine learning algorithm known for its exceptional performance in various tasks.</span></p></li><li><p><span>It is based on the gradient boosting framework, which sequentially adds weak models (typically decision trees) to iteratively improve the overall prediction.</span></p></li><li><p><span>XGBoost incorporates regularization techniques such as shrinkage, column subsampling, and row subsampling to prevent overfitting and enhance generalization.</span></p></li><li><p><span>It supports both classification and regression tasks, making it versatile for a wide range of predictive modeling problems.</span></p></li><li><p><span>XGBoost provides an efficient implementation that optimizes memory usage and computation speed, making it scalable to handle large datasets.</span></p></li><li><p><span>It offers a range of loss functions to accommodate different types of problems, including linear regression, logistic regression, and ranking objectives.</span></p></li><li><p><span>XGBoost can automatically handle missing values by learning their optimal direction during the tree building process.</span></p></li><li><p><span>It includes advanced features like early stopping, which allows the model to stop training early if performance on a validation set does not improve.</span></p></li><li><p><span>XGBoost provides built-in feature selection capabilities, allowing the identification of the most important features for prediction.</span></p></li><li><p><span>It supports parallel processing and can be easily integrated with other machine learning libraries, making it a popular choice among data scientists and Kaggle competition participants.</span></p></li></ol><h3 id='interview-questions'><span>Interview Questions</span></h3><h4 id='what-is-xgboost-and-how-does-it-differ-from-traditional-gradient-boosting-algorithms'><span>What is XGBoost, and how does it differ from traditional gradient boosting algorithms?</span></h4><p><span>XGBoost improves upon traditional gradient boosting algorithms by offering scalability, regularization techniques, efficient handling of missing values, optimized tree construction, and customization options. These enhancements contribute to its popularity and success in various machine learning tasks.</span></p><ol><li><p><span>Scalability: XGBoost is designed to handle large-scale datasets efficiently. It implements parallelization techniques to leverage multi-core processors and distributed computing frameworks, making it faster than traditional gradient boosting algorithms.</span></p></li><li><p><span>Regularization: XGBoost introduces regularization techniques to prevent overfitting and improve generalization. It includes L1 and L2 regularization terms in the objective function to control the complexity of the model and reduce the impact of individual trees.</span></p></li><li><p><span>Handling Missing Values: XGBoost has built-in capabilities to handle missing values in the dataset. It learns the best direction to handle missing values during the tree construction process, eliminating the need for imputation or pre-processing steps.</span></p></li><li><p><span>Tree Construction: XGBoost employs a different approach to construct trees compared to traditional gradient boosting algorithms. It uses a technique called approximate tree learning, which uses quantile sketching and gradient statistics to find optimal splits efficiently.</span></p></li><li><p><span>Sparsity Awareness: XGBoost is designed to handle sparse data efficiently. It employs a data structure known as Compressed Sparse Column (CSC) to represent sparse input matrices, reducing memory usage and speeding up computations.</span></p></li><li><p><span>Customization: XGBoost provides a wide range of hyperparameters that can be tuned to customize the model behavior. It allows control over the learning rate, tree depth, subsampling, regularization parameters, and more, providing flexibility in model design.</span></p></li></ol><h4 id='key-differences-between-xgboost-and-gbdt'><span>Key differences between XGBoost and GBDT</span></h4><p><span>XGBoost (eXtreme Gradient Boosting) and GBDT (Gradient Boosting Decision Trees) are both machine learning models based on gradient boosting algorithms. While they share many similarities, there are also some differences between them. Here are the main differences:</span></p><ol><li><p><strong><span>Regularization Techniques</span></strong><span>: XGBoost introduces regularization techniques, including L1 and L2 regularization, to control model complexity and prevent overfitting. By adding regularization terms in the objective function, XGBoost can effectively control tree growth and improve generalization.</span></p></li><li><p><strong><span>Parallel Computation</span></strong><span>: XGBoost can leverage parallel computation to accelerate model training. It utilizes multi-threading for parallel computation within nodes and also supports distributed computing in a distributed environment. In contrast, GBDT constructs trees sequentially, without direct support for parallel computation.</span></p></li><li><p><strong><span>Custom Loss Functions</span></strong><span>: XGBoost allows users to define custom loss functions to better adapt to specific problems and tasks. Users can define their own loss functions according to their needs and use them in model training. GBDT, on the other hand, only supports predefined loss functions.</span></p></li><li><p><strong><span>Column Block Parallelism</span></strong><span>: XGBoost introduces the concept of column block parallelism, which enables more efficient handling of sparse data and high-dimensional features. It processes data in column blocks, improving computational efficiency, especially for large-scale data and high-dimensional features. GBDT does not have this column block parallelism capability.</span></p></li><li><p><strong><span>Missing Value Handling</span></strong><span>: XGBoost can handle missing values automatically. It can learn the best splitting direction for missing values during tree construction and allocate missing values to appropriate child nodes. GBDT, on the other hand, requires manual handling of missing values during the preprocessing stage.</span></p></li><li><p><strong><span>Feature Importance Estimation</span></strong><span>: XGBoost provides more accurate feature importance estimation methods. It calculates feature importance based on the contributions of features during the model training process, allowing for a more precise evaluation of the impact of features on the model performance. GBDT&#39;s feature importance estimation is relatively simpler, mainly based on the number of times a feature is selected as a splitting feature.</span></p></li></ol><p><span>XGBoost extends GBDT by introducing regularization, parallel computation, custom loss functions, and provides more accurate feature importance estimation. These additional features make XGBoost a powerful and flexible algorithm for various machine learning tasks.</span></p><h4 id='why-does-xgboost-use-second-order-taylor-expansion'><span>Why does XGBoost use second-order Taylor expansion?</span></h4><p><span>XGBoost utilizes second-order Taylor expansion to approximate the loss function and optimize the model training process. There are several important reasons for this approximation:</span></p><ol><li><p><strong><span>More accurate approximation of the loss function</span></strong><span>: Second-order expansion provides a more accurate approximation of the loss function compared to first-order expansion. By considering the local curvature of the loss function around the current model predictions, the second-order expansion better fits the shape of the loss function, leading to a more precise optimization process.</span></p></li><li><p><strong><span>More accurate approximation of gradients and Hessians</span></strong><span>: XGBoost uses second-order Taylor expansion to approximate the loss function and derives the corresponding expressions for first-order gradients and second-order Hessians. These approximations allow for a more accurate estimation of the gradients and Hessians of the loss function, providing reliable information for model parameter updates and optimization.</span></p></li><li><p><strong><span>Accelerated optimization process</span></strong><span>: By using second-order expansion and approximating the gradients and Hessians, XGBoost can optimize the model more quickly. Compared to directly computing the exact gradients and Hessians, utilizing the approximations significantly reduces computational complexity, thereby speeding up the model training process.</span></p></li></ol><p><span>In summary, XGBoost employs second-order Taylor expansion to approximate the loss function and utilizes approximated gradients and Hessians to accelerate the optimization process. This approximation provides a more accurate fit to the loss function and enables XGBoost to optimize the model faster and more accurately.</span></p><h4 id='how-does-xgboost-handle-imbalanced-datasets'><span>How does XGBoost handle imbalanced datasets?</span></h4><p><span>In the case of an imbalanced dataset, where the number of samples in one class (e.g., positive examples) is significantly smaller than the other class (e.g., negative examples), it can pose challenges for training an XGBoost model effectively. The two approaches mentioned aim to address these challenges:</span></p><ol><li><p><strong><span>Balancing the positive and negative weights</span></strong><span>: By using the </span><mark><span>scale_pos_weight</span></mark><span> parameter in XGBoost, you can assign higher weights to the samples from the minority class (positive examples) compared to the majority class (negative examples). This imbalance compensation helps the model to focus more on correctly predicting the positive class, improving its performance. Additionally, using AUC (Area Under the ROC Curve) as the evaluation metric is suitable in this scenario as it measures the model&#39;s ability to rank the examples correctly, regardless of the class distribution.</span></p></li><li><p><strong><span>Setting max_delta_step for predicting the right probability</span></strong><span>: When the goal is to predict the right probability instead of solely focusing on the ranking order, re-balancing the dataset may not be appropriate. In such cases, the </span><code>max_delta_step</code><span> parameter can be used. It limits the maximum step size during the training process and helps in achieving better convergence. Setting a finite value (e.g., 1) for </span><mark><span>max_delta_step</span></mark><span> ensures that the optimization process doesn&#39;t take large steps, preventing the model from making overly confident predictions.</span></p></li></ol><h4 id='in-what-scenarios-is-logistic-regression-lr-preferred-over-gradient-boosting-decision-trees-gbdt'><span>In what scenarios is Logistic Regression (LR) preferred over Gradient Boosting Decision Trees (GBDT)?</span></h4><p><span> Logistic Regression (LR) may be more suitable than Gradient Boosting Decision Trees (GBDT) in the following scenarios:</span></p><ol><li><p><strong><span>Linearly separable problems</span></strong><span>: When the problem is linearly separable, meaning the decision boundaries between classes are linear, logistic regression tends to perform better. LR directly models linear relationships and is well-suited for simple linear problems.</span></p></li><li><p><strong><span>High-dimensional sparse data</span></strong><span>: LR has certain advantages when dealing with high-dimensional sparse datasets. It is easier for LR to perform feature selection in high-dimensional spaces, and it can handle zero-valued features directly without requiring additional treatment for missing values.</span></p></li><li><p><strong><span>Interpretability requirements</span></strong><span>: If model interpretability is a high priority, logistic regression is a more intuitive and interpretable model. The coefficients in logistic regression can be used to explain the impact of each feature on the target variable, while GBDT consists of multiple decision trees, which may be more complex to interpret.</span></p></li><li><p><strong><span>Computational efficiency</span></strong><span>: Logistic regression is a linear model with simple parameter estimation, making it computationally efficient. In contrast, GBDT requires building multiple decision trees and iterative training, which can be more computationally expensive.</span></p></li></ol><p><span>It&#39;s important to note that GBDT remains a powerful model in many scenarios, especially in non-linear, non-sparse datasets, and complex feature relationships. The choice of the appropriate model depends on the characteristics of the data, complexity of the problem, and requirements of the prediction task.</span></p><h4 id='why-can-xgboost-be-trained-in-parallel-how-is-it-trained'><span>Why can XGBoost be trained in parallel? How is it trained?</span></h4><p><span>XGBoost can be trained in parallel due to its design and specific features. Here&#39;s how it is trained:</span></p><ol><li><p><strong><span>Feature Block Parallelism</span></strong><span>: XGBoost adopts a technique called feature block parallelism, where the dataset is divided into blocks based on feature columns. Each block can be processed independently in parallel, allowing for efficient computation, especially with sparse and high-dimensional data.</span></p></li><li><p><strong><span>Tree Level Parallelism</span></strong><span>: Within each feature block, XGBoost leverages tree level parallelism. It parallelizes the construction of decision trees by assigning multiple threads to different tree nodes simultaneously. This parallelization accelerates the training process and improves scalability.</span></p></li><li><p><strong><span>Column Block Splitting</span></strong><span>: XGBoost employs a technique called column block splitting, which is particularly useful when working with data that exceeds the memory capacity. It divides the feature columns into multiple column blocks, and each block is loaded and processed iteratively to conserve memory while maintaining parallelism.</span></p></li><li><p><strong><span>Distributed Computing</span></strong><span>: XGBoost supports distributed computing, allowing the training process to be scaled across multiple machines in a cluster. It utilizes a distributed computing framework like Apache Hadoop or Apache Spark to distribute the computation and handle large-scale datasets.</span></p></li></ol><p><span>In summary, XGBoost can be trained in parallel through feature block parallelism, tree level parallelism, column block splitting, and distributed computing. These techniques enable efficient computation, faster training, and scalability when working with large datasets or in distributed environments.</span></p><h4 id='explain-the-concept-of-boosting-and-how-xgboost-utilizes-it-for-improved-predictive-modeling'><span>Explain the concept of boosting and how XGBoost utilizes it for improved predictive modeling.</span></h4><p><span>Boosting is a machine learning ensemble technique that combines multiple weak models (often referred to as &quot;learners&quot;) to create a stronger and more accurate predictive model. The idea behind boosting is to iteratively train new models that focus on correcting the mistakes made by previous models. Each new model gives more weight to the data points that were misclassified or had high prediction errors by the ensemble of previous models.</span></p><p><span>XGBoost utilizes the boosting concept to improve predictive modeling in the following way:</span></p><ol><li><p><span>Initialization: XGBoost starts with an initial weak model, which is often a simple one like a decision tree with a single node.</span></p></li><li><p><span>Iterative Training: XGBoost performs a series of iterations, where each iteration involves adding a new weak model to the ensemble. The algorithm determines the best location and structure for the new model by optimizing an objective function.</span></p></li><li><p><span>Gradient Descent: XGBoost uses gradient descent optimization to train each weak model. It calculates the gradient of the loss function with respect to the predictions of the ensemble, and the new model is trained to minimize this gradient.</span></p></li><li><p><span>Weighted Updates: XGBoost assigns weights to the data points based on their importance in each iteration. The weights are updated based on the performance of the ensemble up to that point. Misclassified or high-error data points receive higher weights to allow the new model to focus on those instances.</span></p></li><li><p><span>Learning Rate: XGBoost introduces a learning rate (also known as the shrinkage parameter) that controls the contribution of each new model to the ensemble. A lower learning rate makes the ensemble learning more conservative by reducing the impact of each weak model, while a higher learning rate leads to a more aggressive learning process.</span></p></li><li><p><span>Regularization: XGBoost applies regularization techniques such as L1 and L2 regularization to control the complexity of the ensemble and prevent overfitting. Regularization terms are included in the objective function, encouraging simpler models.</span></p></li><li><p><span>Prediction: To make predictions, XGBoost combines the predictions of all weak models in the ensemble. The final prediction is the weighted sum of the individual predictions, where each weak model&#39;s contribution is determined by its performance and the learning rate.</span></p></li></ol><p><span>By iteratively adding new models that focus on correcting the mistakes of previous models, XGBoost builds a strong and accurate ensemble that can generalize well to new data. The combination of gradient descent optimization, weighted updates, regularization, and learning rate control allows XGBoost to efficiently learn complex patterns and improve predictive modeling performance.</span></p><h4 id='what-are-the-advantages-of-using-xgboost-over-other-machine-learning-algorithms'><span>What are the advantages of using XGBoost over other machine learning algorithms?</span></h4><p><img src="https://miro.medium.com/v2/resize:fit:1225/1*U72CpSTnJ-XTjCisJqCqLg.jpeg" referrerpolicy="no-referrer" alt="img"></p><ol><li><p><strong><span>High Performance</span></strong><span>: XGBoost is known for its exceptional performance and speed. It is optimized to handle large-scale datasets efficiently, making it faster than many other algorithms.</span></p></li><li><p><strong><span>Scalability</span></strong><span>: XGBoost is designed to scale horizontally, making it suitable for handling big data. It leverages parallelization techniques to take advantage of multi-core processors and distributed computing frameworks.</span></p></li><li><p><strong><span>Flexibility</span></strong><span>: XGBoost can handle a wide range of data types, including numerical and categorical features. It supports both regression and classification tasks, making it versatile for various predictive modeling problems.</span></p></li><li><p><strong><span>Robustness to Overfitting</span></strong><span>: XGBoost incorporates regularization techniques such as L1 and L2 regularization, which help prevent overfitting and improve the generalization ability of the model.</span></p></li><li><p><strong><span>Handling Missing Values</span></strong><span>: XGBoost has built-in capabilities to handle missing values in the dataset. It automatically learns the best direction to handle missing values during the tree construction process, eliminating the need for manual imputation or preprocessing steps.</span></p></li><li><p><strong><span>Feature Importance</span></strong><span>: XGBoost provides built-in feature selection capabilities and allows for the assessment of feature importance. It ranks the importance of features based on their contribution to the model&#39;s performance, aiding in feature engineering and understanding the underlying patterns.</span></p></li><li><p><strong><span>Optimized Tree Construction</span></strong><span>: XGBoost utilizes an optimized algorithm for tree construction. It employs approximate tree learning techniques, such as quantile sketching and gradient statistics, to find optimal splits efficiently, resulting in faster and more accurate tree building.</span></p></li><li><p><strong><span>Regularized Learning Objective</span></strong><span>: XGBoost offers a variety of loss functions and a customizable learning objective. This allows users to define their specific objectives and tailor the algorithm to their specific problem domain.</span></p></li><li><p><strong><span>Early Stopping</span></strong><span>: XGBoost includes early stopping functionality, which enables automatic stopping of the training process when the model&#39;s performance on a validation set does not improve, preventing overfitting and saving computation time.</span></p></li><li><p><strong><span>Active Community and Industry Adoption</span></strong><span>: XGBoost has gained significant popularity and has a vibrant community. It is widely adopted in both academia and industry, with extensive resources, tutorials, and support available.</span></p></li></ol><h4 id='what-regularization-techniques-are-employed-in-xgboost-to-prevent-overfitting'><span>What regularization techniques are employed in XGBoost to prevent overfitting?</span></h4><p><span>XGBoost (eXtreme Gradient Boosting) employs various regularization techniques to prevent overfitting and enhance the generalization ability of the model. The key regularization techniques used in XGBoost are:</span></p><ol><li><p><strong><span>Shrinkage/learning rate (eta)</span></strong><span>: The shrinkage parameter controls the learning rate of the boosting process. By reducing the contribution of each individual weak learner (tree) added to the ensemble, it makes the learning process more conservative and helps prevent overfitting.</span></p></li><li><p><strong><span>Tree Complexity Control</span></strong><span>: XGBoost includes parameters to control the complexity of the individual trees in the ensemble, such as:</span></p><ul><li><p><strong><span>Max Depth</span></strong><span>: Limits the maximum depth of each tree, preventing them from growing too deep and capturing noisy or irrelevant patterns.</span></p></li><li><p><strong><span>Min Child Weight</span></strong><span>: Specifies the minimum sum of instance weights required in a child node. It acts as a threshold to prevent further partitioning of nodes with low weights, which helps reduce overfitting.</span></p></li></ul></li><li><p><strong><span>Gamma</span></strong><span>: The gamma parameter specifies the minimum loss reduction required to make a further partition on a leaf node of the tree. It controls the complexity of the trees by penalizing splits that do not significantly reduce the loss. Higher gamma values result in more conservative tree growth.</span></p></li><li><p><strong><span>Subsampling</span></strong><span>: XGBoost allows subsampling of the training instances (rows) and features (columns) in each iteration. These parameters, namely subsample and colsample_bytree, control the fraction of data and features to be randomly selected. Subsampling can help reduce overfitting by introducing randomness and diversity into the ensemble.</span></p></li><li><p><strong><span>Regularization Terms</span></strong><span>: XGBoost incorporates L1 (Lasso) and L2 (Ridge) regularization terms in the objective function. These terms add penalties to the complexity of the model by adding the absolute values of the weights (L1) or the squared values of the weights (L2) to the loss function. They encourage sparsity and shrink the magnitude of the weights, respectively, reducing overfitting.</span></p></li><li><p><strong><span>Early Stopping</span></strong><span>: XGBoost implements early stopping functionality, which monitors the performance on a validation set during the training process. If the performance does not improve for a certain number of iterations (defined by the early stopping parameters), the training is stopped early to prevent overfitting and save computational resources.</span></p></li></ol><h4 id='how-does-xgboost-handle-missing-values-in-the-dataset'><span>How does XGBoost handle missing values in the dataset?</span></h4><ol><li><p><strong><span>Learning Direction for Missing Values</span></strong><span>: XGBoost automatically learns the best direction to handle missing values during the tree construction process. It does this by analyzing the distribution of the available data and deciding whether to assign missing values to the left or right child of each tree node. This allows XGBoost to utilize the available information effectively.</span></p></li><li><p><strong><span>Missing Values as a Separate Category</span></strong><span>: XGBoost treats missing values as a separate category or branch in the tree structure. When building the trees, it can create a dedicated child node for missing values, allowing them to be handled explicitly.</span></p></li><li><p><strong><span>Splits Involving Missing Values</span></strong><span>: XGBoost can handle splits involving missing values in a flexible manner. It can evaluate whether a data point has a missing value and navigate the tree structure accordingly, determining which child node to follow based on the presence or absence of the feature value.</span></p></li><li><p><strong><span>Imputation of Missing Values</span></strong><span>: XGBoost does not require explicit imputation or preprocessing of missing values before training. Instead, it can automatically incorporate missing values during the tree building process without the need for imputation techniques such as mean, median, or mode imputation.</span></p></li></ol><p><span>It&#39;s important to note that while XGBoost can handle missing values, it is still recommended to carefully analyze the nature and patterns of missing values in the dataset. Missing values may contain valuable information, and imputation or other preprocessing techniques might be necessary depending on the specific problem and data characteristics.</span></p><h4 id='can-you-briefly-explain-the-objective-functions-available-in-xgboost-for-regression-and-classification-tasks'><span>Can you briefly explain the objective functions available in XGBoost for regression and classification tasks?</span></h4><ol><li><p><strong><span>Regression Objective Functions</span></strong><span>:</span></p><ul><li><p><strong><span>Squared Loss</span></strong><span>: The squared loss (reg:squarederror) is the default objective function for regression in XGBoost. It minimizes the sum of squared differences between the predicted and actual values.</span></p></li><li><p><strong><span>Absolute Loss</span></strong><span>: The absolute loss (reg:linear) minimizes the sum of absolute differences between the predicted and actual values. It is less sensitive to outliers compared to squared loss.</span></p></li><li><p><strong><span>Huber Loss</span></strong><span>: The Huber loss (reg:huber) is a combination of the squared and absolute loss functions. It provides robustness to outliers by using a different loss calculation for smaller and larger errors.</span></p></li><li><p><strong><span>Gamma Loss</span></strong><span>: The gamma loss (reg:gamma) is suitable for modeling the gamma distribution, often used for modeling non-negative continuous variables.</span></p></li><li><p><strong><span>Tweedie Loss</span></strong><span>: The Tweedie loss (reg:tweedie) is designed for modeling data with a Tweedie compound Poisson distribution, which covers a wide range of continuous distributions including normal, gamma, and Poisson.</span></p></li></ul></li><li><p><strong><span>Classification Objective Functions</span></strong><span>:</span></p><ul><li><p><strong><span>Logistic Loss</span></strong><span>: The logistic loss (binary:logistic) is the default objective function for binary classification in XGBoost. It optimizes the logistic loss, which is suitable for binary classification problems where the predicted values are probabilities.</span></p></li><li><p><strong><span>Binary Classification Error</span></strong><span>: The binary classification error (binary:logitraw) minimizes the classification error rate directly.</span></p></li><li><p><strong><span>Multiclass Classification</span></strong><span>: XGBoost supports several objective functions for multiclass classification, such as softmax (multi:softmax), which applies the softmax function to the predicted values, and multiclass logistic loss (multi:softprob), which optimizes the log loss for multiclass classification.</span></p></li></ul></li></ol><h4 id='what-is-the-role-of-the-learning-rate-eta-parameter-in-xgboost-and-how-does-it-affect-the-training-process'><span>What is the role of the learning rate (eta) parameter in XGBoost, and how does it affect the training process?</span></h4><ol><li><p><strong><span>Control over Model Updates</span></strong><span>: The learning rate controls the magnitude of updates applied to the model&#39;s weights during each iteration. A lower learning rate results in smaller updates, making the learning process more conservative, while a higher learning rate leads to more aggressive updates.</span></p></li><li><p><strong><span>Trade-off between Stability and Learning Speed</span></strong><span>: The learning rate provides a trade-off between the stability and learning speed of the model. A lower learning rate makes the training more stable but slower, as each individual weak learner has a smaller impact on the ensemble. Conversely, a higher learning rate speeds up the learning process but may result in more oscillations and instability.</span></p></li><li><p><strong><span>Regularization Effect</span></strong><span>: The learning rate acts as a form of regularization. By reducing the contribution of each individual tree to the ensemble, it helps prevent overfitting and improves the generalization ability of the model. It encourages the model to rely on a larger number of weak learners, reducing the risk of over-reliance on a few strong learners.</span></p></li><li><p><strong><span>Need for Tuning</span></strong><span>: The learning rate is an important hyperparameter that needs to be tuned. It must be carefully chosen to balance the learning speed, stability, and generalization performance of the model. Typically, a lower learning rate requires a higher number of iterations (trees) to achieve optimal performance, while a higher learning rate may lead to faster convergence but with a higher risk of overfitting.</span></p></li><li><p><strong><span>Ensemble of Learning Rates</span></strong><span>: XGBoost employs a strategy called boosting, where new weak learners are added to the ensemble to correct the mistakes of previous models. The learning rate allows each new weak learner to have a specific weight or influence on the ensemble. The final prediction is a weighted sum of the predictions from all weak learners, where the learning rate determines the contribution of each learner.</span></p></li></ol><h4 id='describe-the-process-of-early-stopping-in-xgboost-and-its-purpose'><span>Describe the process of early stopping in XGBoost and its purpose.</span></h4><p><span>Early stopping is a technique used in XGBoost (eXtreme Gradient Boosting) to prevent overfitting and determine the optimal number of boosting iterations (trees) during the training process. The process of early stopping involves monitoring the performance of the model on a separate validation set and stopping the training when the performance no longer improves. Here&#39;s how early stopping works in XGBoost:</span></p><ol><li><p><strong><span>Training and Validation Sets</span></strong><span>: The dataset is split into training and validation sets. The training set is used to build the boosting model, while the validation set is used to monitor the model&#39;s performance during the training process.</span></p></li><li><p><strong><span>Evaluation Metric</span></strong><span>: An evaluation metric is chosen to measure the model&#39;s performance on the validation set. Common evaluation metrics include mean squared error (MSE) for regression tasks or accuracy, precision, recall, or F1-score for classification tasks.</span></p></li><li><p><strong><span>Training Iterations</span></strong><span>: XGBoost starts the training process by iteratively adding weak learners (trees) to the ensemble. After each iteration, the model&#39;s performance is evaluated on the validation set using the chosen evaluation metric.</span></p></li><li><p><strong><span>Early Stopping Condition</span></strong><span>: XGBoost continuously monitors the performance on the validation set. If the performance does not improve after a certain number of iterations or fails to meet a predefined improvement threshold, the early stopping condition is triggered.</span></p></li><li><p><strong><span>Stopping and Final Model</span></strong><span>: When the early stopping condition is met, the training process is stopped, and the model at that iteration is considered the final model. It is selected based on the point where the performance on the validation set was the best.</span></p></li></ol><h4 id='how-does-xgboost-handle-categorical-variables-in-the-dataset'><span>How does XGBoost handle categorical variables in the dataset?</span></h4><ol><li><p><strong><span>One-Hot Encoding</span></strong><span>: By default, XGBoost does not handle categorical variables directly. Therefore, the categorical variables need to be one-hot encoded before feeding them into the algorithm. One-hot encoding represents each category as a binary feature, where each feature corresponds to a unique category, and its value is 1 if the original variable belongs to that category and 0 otherwise.</span></p></li><li><p><strong><span>Sparse Matrix Support</span></strong><span>: XGBoost efficiently handles sparse matrices, which can be beneficial when dealing with high-dimensional one-hot encoded categorical features. Sparse matrices store only non-zero elements, saving memory and computational resources.</span></p></li><li><p><strong><span>Column Sampling</span></strong><span>: XGBoost offers a feature called &quot;colsample_bytree&quot; that allows you to specify the fraction of features (columns) to be randomly sampled at each tree construction. This feature can help reduce the dimensionality and speed up the training process, especially when dealing with a large number of categorical variables.</span></p></li><li><p><strong><span>Built-in Missing Value Handling</span></strong><span>: XGBoost has built-in capabilities to handle missing values. For categorical variables, XGBoost can handle missing values by assigning them a default direction during the tree construction process, similar to how it handles missing values for numerical variables.</span></p></li><li><p><strong><span>Learning-Based Handling (Experimental)</span></strong><span>: XGBoost has recently introduced an experimental feature called &quot;Learning-to-Rank&quot; that enables learning-based handling of categorical variables. This feature allows XGBoost to learn the best split decisions for categorical variables directly from the data, rather than relying on one-hot encoding.</span></p></li></ol><h4 id='what-are-the-key-hyperparameters-in-xgboost-and-how-do-they-impact-the-models-performance'><span>What are the key hyperparameters in XGBoost, and how do they impact the model&#39;s performance?</span></h4><ol><li><p><strong><span>Learning Rate (eta)</span></strong><span>: The learning rate controls the step size or shrinkage rate of the updates made to the model&#39;s weights in each boosting iteration. A lower learning rate makes the training process more conservative but slower, while a higher learning rate leads to faster convergence but may result in overfitting if not properly tuned.</span></p></li><li><p><strong><span>Number of Trees (n_estimators)</span></strong><span>: It represents the number of boosting iterations (trees) to be built. Increasing the number of trees generally improves the model&#39;s performance, but it comes with a trade-off in terms of computational cost. Adding too many trees can lead to overfitting, so it needs to be carefully chosen through techniques like cross-validation.</span></p></li><li><p><strong><span>Tree Depth (max_depth)</span></strong><span>: This parameter controls the maximum depth of each individual tree in the ensemble. A deeper tree can capture more complex interactions but is more prone to overfitting. It is essential to set an appropriate maximum depth based on the complexity of the problem and the dataset.</span></p></li><li><p><strong><span>Minimum Child Weight (min_child_weight)</span></strong><span>: It specifies the minimum sum of instance weights required to create a new split in a tree. Higher values enforce more conservative tree growth by preventing further partitioning of nodes with low weights. It helps control overfitting and is particularly useful when dealing with imbalanced datasets.</span></p></li><li><p><strong><span>Subsampling (subsample)</span></strong><span>: It determines the fraction of training instances (rows) to be randomly sampled for each tree construction iteration. Subsampling introduces randomness and diversity into the ensemble, which can reduce overfitting. However, setting a value too low may lead to underfitting, while a value too high may result in overfitting.</span></p></li><li><p><strong><span>Column Subsampling by Tree (colsample_bytree)</span></strong><span>: It specifies the fraction of features (columns) to be randomly selected at each tree construction iteration. Similar to subsampling, it introduces randomness and reduces the risk of overfitting. It is particularly useful when dealing with high-dimensional datasets with many features.</span></p></li><li><p><strong><span>Regularization Parameters (lambda and alpha)</span></strong><span>: Lambda (L2 regularization) and alpha (L1 regularization) control the amount of regularization applied to the weights of the model. They help prevent overfitting by adding penalties to the complexity of the model. Lambda encourages weights to be smaller, while alpha encourages sparsity by driving some weights to zero.</span></p></li><li><p><strong><span>Early Stopping (early_stopping_rounds)</span></strong><span>: This parameter enables early stopping functionality, allowing the training process to stop if the performance on the validation set does not improve for a specified number of iterations. It helps prevent overfitting and saves computational resources.</span></p></li></ol><h4 id='how-can-you-assess-the-importance-of-features-in-an-xgboost-model'><span>How can you assess the importance of features in an XGBoost model?</span></h4><ol><li><p><strong><span>Feature Importance Plot</span></strong><span>: XGBoost offers a built-in feature importance plot that ranks features based on their importance score. The importance score reflects the number of times a feature is used to split across all the trees in the model. The higher the score, the more important the feature. This plot provides a quick visual overview of feature importance.</span></p></li><li><p><strong><span>Feature Importance Values</span></strong><span>: XGBoost provides access to the feature importance values, which can be obtained programmatically. The importance values represent the average gain of each feature over all the trees in the ensemble. Higher values indicate greater importance.</span></p></li><li><p><strong><span>Gini Importance</span></strong><span>: XGBoost can calculate the Gini importance, which is based on the total reduction of the Gini impurity criterion achieved by a feature across all the trees. Features with higher Gini importance are considered more important.</span></p></li><li><p><strong><span>Permutation Importance</span></strong><span>: Permutation importance is a technique that involves randomly permuting the values of a single feature and measuring the resulting impact on the model&#39;s performance. XGBoost allows you to calculate permutation importance by evaluating the change in evaluation metric (e.g., accuracy or mean squared error) when a feature&#39;s values are permuted. A greater decrease in performance indicates higher importance.</span></p></li><li><p><strong><span>SHAP Values</span></strong><span>: SHAP (SHapley Additive exPlanations) values provide a unified approach to interpret the impact of each feature on individual predictions. XGBoost can generate SHAP values that represent the contribution of each feature for each instance. Aggregating these values across the dataset helps assess the global importance of features.</span></p></li></ol><h4 id='what-is-the-difference-between-xgboosts-tree-based-and-linear-base-learners'><span>What is the difference between XGBoost&#39;s tree-based and linear base learners?</span></h4><ol><li><p><strong><span>Tree-Based Base Learners</span></strong><span>: Tree-based base learners are decision trees, which are the default choice in XGBoost. These base learners are composed of nodes and branches that make hierarchical splits based on feature values. Each leaf node represents a prediction. Tree-based base learners have the following characteristics:</span></p><ul><li><p><span>They can model complex nonlinear relationships between features and the target variable.</span></p></li><li><p><span>They handle both numerical and categorical features by making binary splits.</span></p></li><li><p><span>They can capture feature interactions and non-linear patterns in the data.</span></p></li><li><p><span>They are prone to overfitting if not properly regularized.</span></p></li></ul></li><li><p><strong><span>Linear Base Learners</span></strong><span>: Linear base learners represent a linear model, where the prediction is a linear combination of the input features. These base learners have the following characteristics:</span></p><ul><li><p><span>They model linear relationships between features and the target variable.</span></p></li><li><p><span>They are useful when the relationships between features and the target are primarily linear.</span></p></li><li><p><span>They are less flexible in capturing complex nonlinear patterns.</span></p></li><li><p><span>They are less prone to overfitting due to their inherent linearity.</span></p></li><li><p><span>They can handle high-dimensional datasets more efficiently.</span></p></li></ul></li></ol><p><span>The choice between tree-based and linear base learners depends on the nature of the data and the problem at hand. Tree-based base learners are generally more flexible and can capture complex relationships, making them suitable for a wide range of tasks. However, they may require careful tuning to prevent overfitting. On the other hand, linear base learners are more interpretable and efficient for high-dimensional datasets with linear relationships. XGBoost allows you to specify the base learner type based on the specific requirements of your problem.</span></p><h4 id='explain-the-concept-of-ensemble-learning-and-how-it-is-utilized-in-xgboost'><span>Explain the concept of ensemble learning and how it is utilized in XGBoost.</span></h4><ol><li><p><strong><span>Boosting</span></strong><span>: XGBoost is based on the boosting framework, which involves sequentially adding weak learners (base models) to an ensemble. Each weak learner is trained to correct the mistakes made by the previous learners. In XGBoost, the weak learners are decision trees, either tree-based or linear.</span></p></li><li><p><strong><span>Gradient Boosting</span></strong><span>: XGBoost uses gradient boosting, where the weak learners are added to the ensemble in a stage-wise manner. The subsequent weak learners are trained to minimize the errors (residuals) of the previous learners. This gradient-based approach allows XGBoost to focus on the samples that are challenging to predict, improving the overall model performance.</span></p></li><li><p><strong><span>Weighted Voting</span></strong><span>: XGBoost assigns weights to each weak learner based on its performance and contribution to the ensemble. The weights reflect the importance of each learner&#39;s predictions when making the final prediction. Weak learners that perform well and have low errors are given higher weights, while those with higher errors receive lower weights.</span></p></li><li><p><strong><span>Regularization and Control</span></strong><span>: XGBoost applies regularization techniques to control the complexity and overfitting of the ensemble. Regularization parameters, such as lambda (L2 regularization) and alpha (L1 regularization), are used to add penalties to the complexity of the model. Regularization helps prevent overfitting and improves the generalization ability of the ensemble.</span></p></li><li><p><strong><span>Combining Predictions</span></strong><span>: The final prediction in XGBoost is made by combining the predictions of all the weak learners in the ensemble, weighted by their respective weights. The combination can be a simple average, weighted average, or other techniques based on the specific task (regression or classification).</span></p></li></ol><p><span>By utilizing ensemble learning through gradient boosting, XGBoost improves the performance and robustness of predictions. It combines multiple weak learners to create a strong ensemble that can handle complex relationships, capture non-linear patterns, and achieve better accuracy compared to individual models. The sequential training and weighted voting process in XGBoost ensure that the ensemble learns from previous mistakes and focuses on challenging samples, enhancing the overall predictive power of the model.</span></p><h4 id='how-can-you-tune-the-hyperparameters-of-an-xgboost-model-to-improve-its-performance'><span>How can you tune the hyperparameters of an XGBoost model to improve its performance?</span></h4><ol><li><p><strong><span>Start with Default Parameters</span></strong><span>: Begin by using the default parameters of XGBoost, as they are often a good starting point and can yield reasonable results.</span></p></li><li><p><strong><span>Define Evaluation Metrics</span></strong><span>: Clearly define the evaluation metrics that align with your problem, such as mean squared error (MSE) for regression or accuracy for classification. These metrics will guide the hyperparameter tuning process.</span></p></li><li><p><strong><span>Grid Search</span></strong><span>: Perform a grid search by defining a set of possible values for each hyperparameter of interest. Train and evaluate the XGBoost model using each combination of hyperparameters and select the one that gives the best performance. Grid search is an exhaustive but computationally expensive approach.</span></p></li><li><p><strong><span>Random Search</span></strong><span>: Alternatively, use random search to randomly sample combinations of hyperparameters within predefined ranges. This approach can be more efficient than grid search, especially when the search space is large.</span></p></li><li><p><strong><span>Cross-Validation</span></strong><span>: Perform cross-validation to assess the performance of different hyperparameter configurations. Split your training data into multiple folds, train and evaluate the XGBoost model on each fold, and average the results. This helps to reduce the impact of randomness and provide a more reliable estimate of performance.</span></p></li><li><p><strong><span>Early Stopping</span></strong><span>: Utilize early stopping to prevent overfitting and save computational resources. Monitor the performance of the model on a validation set during training and stop the training process if the performance does not improve for a certain number of iterations.</span></p></li><li><p><strong><span>Learning Rate and Number of Trees</span></strong><span>: Experiment with the learning rate (eta) and number of trees (n_estimators) as they significantly impact the model. Lower learning rates and higher numbers of trees can improve accuracy but require more computational resources.</span></p></li><li><p><strong><span>Regularization Parameters</span></strong><span>: Tune the regularization parameters, lambda (L2 regularization) and alpha (L1 regularization), to control the complexity of the model and prevent overfitting. Higher values of lambda and alpha increase the regularization strength.</span></p></li><li><p><strong><span>Feature Importance</span></strong><span>: Assess the feature importance provided by XGBoost to identify and prioritize the most influential features. Consider removing irrelevant or redundant features to simplify the model.</span></p></li><li><p><strong><span>Iterative Process</span></strong><span>: Hyperparameter tuning is an iterative process. Experiment with different combinations, evaluate the performance, and fine-tune the parameters based on the results. It may require multiple iterations to find the optimal hyperparameters.</span></p></li></ol><h4 id='can-you-compare-xgboost-with-random-forest-and-highlight-their-differences-and-similarities'><span>Can you compare XGBoost with Random Forest and highlight their differences and similarities?</span></h4><p><strong><span>Differences:</span></strong></p><ol><li><p><strong><span>Algorithm Type</span></strong><span>: XGBoost is a boosting algorithm, while Random Forest is an ensemble algorithm.</span></p></li><li><p><strong><span>Training Approach</span></strong><span>: XGBoost builds trees sequentially, optimizing the objective function through gradient-based boosting, while Random Forest builds trees independently using bootstrap aggregating (bagging).</span></p></li><li><p><strong><span>Handling of Missing Values</span></strong><span>: XGBoost has built-in capability to handle missing values, while Random Forest can only handle missing values by imputation or exclusion.</span></p></li><li><p><strong><span>Feature Subsets</span></strong><span>: Random Forest selects a random subset of features at each split, whereas XGBoost considers all features for each split and utilizes feature importance for selection.</span></p></li><li><p><strong><span>Complexity</span></strong><span>: XGBoost can capture complex relationships and interactions in the data, while Random Forest typically handles simpler relationships between features and the target variable.</span></p></li></ol><p><strong><span>Similarities:</span></strong></p><ol><li><p><strong><span>Ensemble Learning</span></strong><span>: Both XGBoost and Random Forest utilize ensemble learning techniques to combine multiple weak learners (trees) to make predictions.</span></p></li><li><p><strong><span>Handling of Categorical Variables</span></strong><span>: Both algorithms can handle categorical variables directly, converting them into numerical representations suitable for tree-based models.</span></p></li><li><p><strong><span>Regularization</span></strong><span>: XGBoost and Random Forest offer options for regularization to prevent overfitting. XGBoost has regularization parameters like lambda and alpha, while Random Forest uses techniques like maximum tree depth and minimum sample split.</span></p></li><li><p><strong><span>Feature Importance</span></strong><span>: Both XGBoost and Random Forest provide measures of feature importance, which can help identify the most influential features in the model.</span></p></li></ol><p><span>What are some potential limitations or challenges when working with XGBoost?</span></p><ol><li><p><strong><span>Computational Complexity</span></strong><span>: XGBoost can be computationally expensive, especially when dealing with large datasets or complex models with a large number of trees and high-dimensional feature spaces. Training time and memory usage can become significant challenges.</span></p></li><li><p><strong><span>Hyperparameter Tuning</span></strong><span>: XGBoost has several hyperparameters that need to be tuned, such as learning rate, tree depth, number of trees, regularization parameters, and more. Finding the optimal combination of hyperparameters requires experimentation and can be time-consuming.</span></p></li><li><p><strong><span>Data Preprocessing</span></strong><span>: XGBoost does not handle categorical variables directly. They need to be preprocessed and converted into numerical representations, which may require additional effort and consideration.</span></p></li><li><p><strong><span>Feature Engineering</span></strong><span>: The performance of XGBoost heavily relies on the quality of the features. Feature engineering, including feature selection, transformation, and creation, is crucial for obtaining meaningful and informative features.</span></p></li><li><p><strong><span>Sensitive to Outliers</span></strong><span>: XGBoost can be sensitive to outliers, as the algorithm tries to minimize the loss function. Outliers can disproportionately affect the model&#39;s training process and lead to suboptimal results. Proper handling of outliers is essential.</span></p></li><li><p><strong><span>Imbalanced Data</span></strong><span>: XGBoost may struggle with imbalanced datasets, where one class significantly outweighs the others. It requires careful consideration of techniques such as class weighting, oversampling, or undersampling to address the class imbalance issue.</span></p></li><li><p><strong><span>Interpretability</span></strong><span>: While XGBoost provides feature importance measures, the overall model interpretability can be challenging due to its complex ensemble nature. Understanding the relationships between features and predictions can be difficult compared to simpler models like linear regression.</span></p></li><li><p><strong><span>Limited Handling of Text and Image Data</span></strong><span>: XGBoost is primarily designed for structured data and may not be the best choice for tasks involving unstructured data such as text or image analysis. Specialized models or preprocessing techniques may be required for such data types.</span></p></li></ol><h4 id='how-can-you-interpret-the-output-of-an-xgboost-model-in-terms-of-feature-importance'><span>How can you interpret the output of an XGBoost model in terms of feature importance?</span></h4><ol><li><p><strong><span>Gain Importance</span></strong><span>: XGBoost calculates feature importance based on the average gain of each feature across all splits in the trees. The gain represents the improvement in the objective function (e.g., reduction in training loss) achieved by a particular feature when it is chosen for splitting. Higher gain values indicate more important features.</span></p></li><li><p><strong><span>Plotting Feature Importance</span></strong><span>: XGBoost provides a built-in method to plot the feature importance. By using the </span><code>plot_importance()</code><span> function, you can generate a bar plot showing the relative importance of each feature. The plot is usually sorted in descending order of importance.</span></p></li><li><p><strong><span>Quantitative Importance Measures</span></strong><span>: XGBoost assigns an importance score to each feature, which represents the relative importance compared to the sum of all feature importance scores. This score can be accessed through the </span><code>feature_importances_</code><span> attribute of the trained XGBoost model. You can retrieve the importance scores and use them for further analysis or ranking the features.</span></p></li><li><p><strong><span>Feature Selection</span></strong><span>: Feature importance can guide feature selection or dimensionality reduction. By considering the most important features and discarding less relevant ones, you can simplify the model, improve its interpretability, and potentially reduce overfitting.</span></p></li><li><p><strong><span>Contextual Interpretation</span></strong><span>: Remember that feature importance is relative to the other features within the model. It is important to interpret feature importance in the context of the specific problem and dataset. A feature may have high importance in one model but lower importance when combined with other features in a different model.</span></p></li><li><p><strong><span>Domain Knowledge</span></strong><span>: While feature importance provides valuable insights, it is essential to combine it with domain knowledge and understanding of the data. Some features may have high importance due to their correlation with the target variable, but their practical significance or causal relationship may need further investigation.</span></p></li></ol><h4 id='are-there-any-specific-scenarios-or-types-of-data-where-xgboost-is-particularly-effective-or-not-suitable'><span>Are there any specific scenarios or types of data where XGBoost is particularly effective or not suitable?</span></h4><p><strong><span>Scenarios where XGBoost is particularly effective:</span></strong></p><ol><li><p><strong><span>Tabular Data</span></strong><span>: XGBoost is highly effective for structured/tabular data where the features are well-defined and have clear relationships with the target variable. It excels in problems such as regression, classification, and ranking tasks.</span></p></li><li><p><strong><span>Large and Complex Datasets</span></strong><span>: XGBoost can handle large datasets with high dimensionality and a large number of features. It can capture complex relationships and interactions between features, making it suitable for challenging and diverse datasets.</span></p></li><li><p><strong><span>Imbalanced Data</span></strong><span>: XGBoost provides options to address class imbalance, such as weighted loss functions or subsampling, making it effective in handling imbalanced datasets where one class is underrepresented.</span></p></li><li><p><strong><span>Feature Importance</span></strong><span>: XGBoost&#39;s ability to provide feature importance measures helps identify the most influential features in the model. This can be beneficial in feature selection, feature engineering, and gaining insights into the underlying data.</span></p></li><li><p><strong><span>Ensemble Learning</span></strong><span>: XGBoost&#39;s boosting framework allows it to build strong ensemble models by combining multiple weak learners. This makes it particularly effective in improving model performance and generalization.</span></p></li></ol><p><strong><span>Scenarios where XGBoost may be less suitable:</span></strong></p><ol><li><p><strong><span>Text and Image Data</span></strong><span>: XGBoost is primarily designed for structured data and may not be the best choice for unstructured data such as text or image analysis. Specialized models or preprocessing techniques like NLP or CNNs are often more suitable for these types of data.</span></p></li><li><p><strong><span>Small Datasets</span></strong><span>: XGBoost&#39;s power comes from the ability to capture complex patterns and interactions, but it requires a sufficient amount of data to generalize well. When dealing with small datasets, XGBoost may be prone to overfitting, and simpler models or techniques like regularization may be more appropriate.</span></p></li><li><p><strong><span>Real-time Predictions</span></strong><span>: XGBoost can be computationally expensive, especially when dealing with large models or complex datasets. In scenarios where real-time predictions are required, the model&#39;s computational requirements may be a limitation.</span></p></li><li><p><strong><span>Highly Noisy Data</span></strong><span>: XGBoost is sensitive to noisy data or outliers. If the dataset contains a significant amount of noise, extreme outliers, or erroneous observations, it may impact the model&#39;s performance.</span></p></li></ol><h4 id='what-are-some-practical-considerations-for-implementing-xgboost-in-a-production-environment'><span>What are some practical considerations for implementing XGBoost in a production environment?</span></h4><ol><li><p><strong><span>Data Preprocessing</span></strong><span>: Ensure that the data preprocessing steps used during training are applied consistently in the production environment. This includes handling missing values, encoding categorical variables, scaling or normalizing features, and any other necessary data transformations.</span></p></li><li><p><strong><span>Feature Engineering</span></strong><span>: Pay attention to feature engineering techniques used during model development. It&#39;s crucial to maintain consistency in feature engineering between training and production to ensure accurate predictions. Any new features or feature modifications should be applied consistently.</span></p></li><li><p><strong><span>Model Deployment</span></strong><span>: Decide on an appropriate method to deploy the trained XGBoost model in the production environment. This can include options such as deploying as a REST API, embedding it within an application, or utilizing a model serving infrastructure like TensorFlow Serving or SageMaker.</span></p></li><li><p><strong><span>Scalability and Performance</span></strong><span>: Consider the scalability and performance requirements of the production system. XGBoost can be computationally expensive, especially with large models or high-throughput prediction scenarios. Ensure that the production environment has sufficient computational resources to handle the workload efficiently.</span></p></li><li><p><strong><span>Monitoring and Versioning</span></strong><span>: Implement mechanisms to monitor the performance of the deployed XGBoost model. This includes tracking prediction accuracy, monitoring prediction latency, and logging model outputs for analysis. Additionally, establish version control to keep track of different model versions and facilitate model rollback or comparison.</span></p></li><li><p><strong><span>Updating and Retraining</span></strong><span>: Determine a strategy for updating and retraining the XGBoost model as new data becomes available or the model performance degrades. Establish a process to periodically evaluate model performance, monitor data drift, and trigger model retraining or updates when necessary.</span></p></li><li><p><strong><span>Error Handling and Robustness</span></strong><span>: Implement proper error handling and exception management mechanisms in the production system. This includes handling potential issues such as missing or invalid inputs, network failures, or model-related errors. Ensure that the system gracefully handles these scenarios and provides appropriate feedback or fallback options.</span></p></li><li><p><strong><span>Security and Privacy</span></strong><span>: Consider security and privacy aspects when implementing XGBoost in a production environment. Protect sensitive data, ensure secure communication channels, and comply with privacy regulations and best practices.</span></p></li><li><p><strong><span>Documentation and Collaboration</span></strong><span>: Document the implementation process, including data preprocessing steps, model configuration, and deployment details. Foster collaboration and communication among data scientists, developers, and stakeholders involved in the production pipeline.</span></p></li></ol><h4 id='what-are-the-differences-between-xgboost-and-lightgbm'><span>What are the differences between XGBoost and LightGBM?</span></h4><ol><li><p><strong><span>Algorithmic approach</span></strong><span>: XGBoost uses a pre-sort-based algorithm, where the dataset is sorted based on feature values to find optimal split points. In contrast, LightGBM uses a histogram-based algorithm, constructing histograms of feature values to efficiently find split points. This difference affects computational efficiency and memory usage.</span></p></li><li><p><strong><span>Handling of categorical features</span></strong><span>: LightGBM has built-in support for handling categorical features, while XGBoost requires one-hot encoding or other methods to encode categorical variables. LightGBM can directly work with categorical features by partitioning them in the histogram construction process, which is more convenient and efficient.</span></p></li><li><p><strong><span>Data parallelism</span></strong><span>: LightGBM employs data parallelism, where different machines or threads handle different data partitions simultaneously. This parallelization strategy improves training speed, especially for large datasets. On the other hand, XGBoost focuses on feature parallelism, where each machine or thread handles a subset of features during training.</span></p></li><li><p><strong><span>Memory usage</span></strong><span>: LightGBM is designed to be memory-efficient. Its histogram-based algorithm and data partitioning techniques enable it to use less memory compared to XGBoost, especially for large datasets or datasets with many features.</span></p></li><li><p><strong><span>Performance</span></strong><span>: XGBoost and LightGBM have shown competitive performance in various machine learning tasks. However, their differences in algorithmic approaches, handling of categorical features, parallelization strategies, and memory usage make one framework potentially more suitable than the other depending on the specific dataset and problem.</span></p></li></ol><h3 id='python-implement'><span>Python Implement</span></h3><h4 id='using-sklearn'><span>Using Sklearn</span></h4><pre class="md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded" spellcheck="false" lang="python" style="break-inside: unset;"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="python"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 11.0759px; left: 42px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 38px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><span><span>​</span>x</span><div class="CodeMirror-linenumber CodeMirror-gutter-elt"><div>53</div></div></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div style="position: relative;" class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: -38px; width: 38px;"></div><div class="CodeMirror-gutter-wrapper CodeMirror-activeline-gutter" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 29px;">1</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">import</span> <span class="cm-variable">numpy</span> <span class="cm-keyword">as</span> <span class="cm-variable">np</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">2</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">from</span> <span class="cm-variable">sklearn</span>.<span class="cm-property">datasets</span> <span class="cm-keyword">import</span> <span class="cm-variable">load_iris</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">3</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">from</span> <span class="cm-variable">sklearn</span>.<span class="cm-property">model_selection</span> <span class="cm-keyword">import</span> <span class="cm-variable">train_test_split</span>, <span class="cm-variable">GridSearchCV</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">4</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">from</span> <span class="cm-variable">sklearn</span>.<span class="cm-property">metrics</span> <span class="cm-keyword">import</span> <span class="cm-variable">accuracy_score</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">5</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">import</span> <span class="cm-variable">xgboost</span> <span class="cm-keyword">as</span> <span class="cm-variable">xgb</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">6</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="" cm-zwsp="">
</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">7</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment"># Load the Iris dataset</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">8</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">iris</span> <span class="cm-operator">=</span> <span class="cm-variable">load_iris</span>()</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">9</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">X</span> <span class="cm-operator">=</span> <span class="cm-variable">iris</span>.<span class="cm-property">data</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 29px;">10</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">y</span> <span class="cm-operator">=</span> <span class="cm-variable">iris</span>.<span class="cm-property">target</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">11</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="" cm-zwsp="">
</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">12</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment"># Split the dataset into training and testing sets</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">13</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">X_train</span>, <span class="cm-variable">X_test</span>, <span class="cm-variable">y_train</span>, <span class="cm-variable">y_test</span> <span class="cm-operator">=</span> <span class="cm-variable">train_test_split</span>(<span class="cm-variable">X</span>, <span class="cm-variable">y</span>, <span class="cm-variable">test_size</span><span class="cm-operator">=</span><span class="cm-number">0.2</span>, <span class="cm-variable">random_state</span><span class="cm-operator">=</span><span class="cm-number">42</span>)</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">14</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="" cm-zwsp="">
</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">15</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment"># Convert the data into DMatrix format for XGBoost</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">16</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">dtrain</span> <span class="cm-operator">=</span> <span class="cm-variable">xgb</span>.<span class="cm-property">DMatrix</span>(<span class="cm-variable">X_train</span>, <span class="cm-variable">label</span><span class="cm-operator">=</span><span class="cm-variable">y_train</span>)</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">17</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">dtest</span> <span class="cm-operator">=</span> <span class="cm-variable">xgb</span>.<span class="cm-property">DMatrix</span>(<span class="cm-variable">X_test</span>, <span class="cm-variable">label</span><span class="cm-operator">=</span><span class="cm-variable">y_test</span>)</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">18</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="" cm-zwsp="">
</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">19</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment"># Set the parameters for XGBoost</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 29px;">20</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">params</span> <span class="cm-operator">=</span> {</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">21</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-string">'objective'</span>: <span class="cm-string">'multi:softmax'</span>,</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">22</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-string">'num_class'</span>: <span class="cm-number">3</span>,</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">23</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-string">'max_depth'</span>: <span class="cm-number">3</span>,</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">24</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-string">'eta'</span>: <span class="cm-number">0.1</span>,</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">25</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-string">'eval_metric'</span>: <span class="cm-string">'merror'</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">26</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">27</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="" cm-zwsp="">
</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">28</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment"># Define the range of hyperparameters to search</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">29</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">param_grid</span> <span class="cm-operator">=</span> {</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 29px;">30</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-string">'max_depth'</span>: [<span class="cm-number">3</span>, <span class="cm-number">5</span>, <span class="cm-number">7</span>],</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">31</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-string">'eta'</span>: [<span class="cm-number">0.1</span>, <span class="cm-number">0.01</span>, <span class="cm-number">0.001</span>],</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">32</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-string">'min_child_weight'</span>: [<span class="cm-number">1</span>, <span class="cm-number">3</span>, <span class="cm-number">5</span>]</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">33</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">34</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="" cm-zwsp="">
</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">35</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment"># Perform grid search to find the best hyperparameters</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">36</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">grid_search</span> <span class="cm-operator">=</span> <span class="cm-variable">GridSearchCV</span>(<span class="cm-variable">estimator</span><span class="cm-operator">=</span><span class="cm-variable">xgb</span>.<span class="cm-property">XGBClassifier</span>(<span class="cm-operator">**</span><span class="cm-variable">params</span>), <span class="cm-variable">param_grid</span><span class="cm-operator">=</span><span class="cm-variable">param_grid</span>, <span class="cm-variable">cv</span><span class="cm-operator">=</span><span class="cm-number">5</span>)</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">37</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">grid_search</span>.<span class="cm-property">fit</span>(<span class="cm-variable">X_train</span>, <span class="cm-variable">y_train</span>)</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">38</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="" cm-zwsp="">
</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">39</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment"># Get the best hyperparameters</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 29px;">40</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">best_params</span> <span class="cm-operator">=</span> <span class="cm-variable">grid_search</span>.<span class="cm-property">best_params_</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">41</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-builtin">print</span>(<span class="cm-string">"Best Hyperparameters:"</span>, <span class="cm-variable">best_params</span>)</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">42</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="" cm-zwsp="">
</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">43</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment"># Train the XGBoost model with the best hyperparameters</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">44</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">num_rounds</span> <span class="cm-operator">=</span> <span class="cm-number">100</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">45</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">model</span> <span class="cm-operator">=</span> <span class="cm-variable">xgb</span>.<span class="cm-property">train</span>(<span class="cm-variable">best_params</span>, <span class="cm-variable">dtrain</span>, <span class="cm-variable">num_rounds</span>)</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">46</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="" cm-zwsp="">
</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">47</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment"># Make predictions on the test set</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">48</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">predictions</span> <span class="cm-operator">=</span> <span class="cm-variable">model</span>.<span class="cm-property">predict</span>(<span class="cm-variable">dtest</span>)</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">49</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="" cm-zwsp="">
</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 29px;">50</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment"># Evaluate the accuracy of the model</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">51</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">accuracy</span> <span class="cm-operator">=</span> <span class="cm-variable">accuracy_score</span>(<span class="cm-variable">y_test</span>, <span class="cm-variable">predictions</span>)</span></pre></div><div class="" style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 29px;">52</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-builtin">print</span>(<span class="cm-string">"Accuracy:"</span>, <span class="cm-variable">accuracy</span>)</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 1360px;"></div><div class="CodeMirror-gutters" style="height: 1360px;"><div class="CodeMirror-gutter CodeMirror-linenumbers" style="width: 37px;"></div></div></div></div></pre><p><span>In this example, we added the hyperparameter tuning process using </span><code>GridSearchCV</code><span> from scikit-learn. We define a grid of hyperparameters to search through, including </span><code>max_depth</code><span>, </span><code>eta</code><span>, and </span><code>min_child_weight</code><span>. The </span><code>cv</code><span> parameter in </span><code>GridSearchCV</code><span> specifies the number of cross-validation folds.</span></p><p><span>We perform a grid search using </span><code>fit()</code><span> to find the best hyperparameters for the XGBoost model. The best hyperparameters are obtained using </span><code>best_params_</code><span> attribute.</span></p><p><span>Next, we train the XGBoost model with the best hyperparameters using </span><code>xgb.train()</code><span>. The remaining steps for making predictions and evaluating the accuracy of the model remain the same.</span></p><h4 id='how-to-train-xgboost-model-with-pyspark'><span>How to Train XGBoost Model With PySpark</span></h4><pre class="md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded" spellcheck="false" lang="python" style="break-inside: unset;"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="python"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 11.0759px; left: 42px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 38px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre><div class="CodeMirror-linenumber CodeMirror-gutter-elt"><div>1</div></div><div class="CodeMirror-linenumber CodeMirror-gutter-elt"><div>43</div></div></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div style="position: relative;" class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: -38px; width: 38px;"></div><div class="CodeMirror-gutter-wrapper CodeMirror-activeline-gutter" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 29px;">1</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment"># Step 1: Install the necessary libraries</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">2</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-operator">!</span><span class="cm-variable">pip</span> <span class="cm-variable">install</span> <span class="cm-variable">sparkxgb</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">3</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="" cm-zwsp="">
</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">4</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment"># Step 2: Import the necessary modules</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">5</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">from</span> <span class="cm-variable">sparkxgb</span> <span class="cm-keyword">import</span> <span class="cm-variable">XGBoostClassifier</span>, <span class="cm-variable">XGBoostRegressor</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">6</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">from</span> <span class="cm-variable">pyspark</span>.<span class="cm-property">ml</span>.<span class="cm-property">evaluation</span> <span class="cm-keyword">import</span> <span class="cm-variable">BinaryClassificationEvaluator</span>, <span class="cm-variable">RegressionEvaluator</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">7</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">from</span> <span class="cm-variable">pyspark</span>.<span class="cm-property">ml</span> <span class="cm-keyword">import</span> <span class="cm-variable">Pipeline</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">8</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="" cm-zwsp="">
</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">9</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment"># Step 3: Create a PySpark DataFrame</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 29px;">10</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment"># Assuming you have already loaded your data into a DataFrame called 'data'</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">11</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="" cm-zwsp="">
</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">12</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment"># Step 4: Split the data into training and test sets</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">13</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">train_data</span>, <span class="cm-variable">test_data</span> <span class="cm-operator">=</span> <span class="cm-variable">data</span>.<span class="cm-property">randomSplit</span>([<span class="cm-number">0.8</span>, <span class="cm-number">0.2</span>], <span class="cm-variable">seed</span><span class="cm-operator">=</span><span class="cm-number">42</span>)</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">14</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="" cm-zwsp="">
</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">15</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment"># Step 5: Define the XGBoost model</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">16</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">xgb_model</span> <span class="cm-operator">=</span> <span class="cm-variable">XGBoostClassifier</span>(</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">17</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">featuresCol</span><span class="cm-operator">=</span><span class="cm-string">'features'</span>,</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">18</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">labelCol</span><span class="cm-operator">=</span><span class="cm-string">'label'</span>,</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">19</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">objective</span><span class="cm-operator">=</span><span class="cm-string">'binary:logistic'</span>,</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 29px;">20</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">numRound</span><span class="cm-operator">=</span><span class="cm-number">100</span>,</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">21</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">earlyStoppingRound</span><span class="cm-operator">=</span><span class="cm-number">10</span>,</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">22</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">evalMetric</span><span class="cm-operator">=</span><span class="cm-string">'auc'</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">23</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">)</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">24</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="" cm-zwsp="">
</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">25</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment"># Step 6: Create a pipeline</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">26</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">pipeline</span> <span class="cm-operator">=</span> <span class="cm-variable">Pipeline</span>(<span class="cm-variable">stages</span><span class="cm-operator">=</span>[<span class="cm-variable">xgb_model</span>])</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">27</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="" cm-zwsp="">
</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">28</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment"># Step 7: Fit the pipeline</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">29</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">model</span> <span class="cm-operator">=</span> <span class="cm-variable">pipeline</span>.<span class="cm-property">fit</span>(<span class="cm-variable">train_data</span>)</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 29px;">30</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="" cm-zwsp="">
</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">31</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment"># Step 8: Make predictions</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">32</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">predictions</span> <span class="cm-operator">=</span> <span class="cm-variable">model</span>.<span class="cm-property">transform</span>(<span class="cm-variable">test_data</span>)</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">33</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="" cm-zwsp="">
</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">34</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment"># Step 9: Evaluate the model</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">35</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">evaluator</span> <span class="cm-operator">=</span> <span class="cm-variable">BinaryClassificationEvaluator</span>()</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">36</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">auc</span> <span class="cm-operator">=</span> <span class="cm-variable">evaluator</span>.<span class="cm-property">evaluate</span>(<span class="cm-variable">predictions</span>)</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">37</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-builtin">print</span>(<span class="cm-string">'AUC:'</span>, <span class="cm-variable">auc</span>)</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">38</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="" cm-zwsp="">
</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">39</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment"># For regression, use the following evaluation code instead:</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 29px;">40</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment"># evaluator = RegressionEvaluator()</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 29px;">41</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment"># rmse = evaluator.evaluate(predictions, {evaluator.metricName: 'rmse'})</span></span></pre></div><div class="" style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -38px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 29px;">42</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment"># print('RMSE:', rmse)</span></span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 1098px;"></div><div class="CodeMirror-gutters" style="height: 1098px;"><div class="CodeMirror-gutter CodeMirror-linenumbers" style="width: 37px;"></div></div></div></div></pre><p>&nbsp;</p></div></div>
</body>
</html>