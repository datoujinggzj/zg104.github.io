<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>产能预测模型V1</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__html"><h1 id="产能预测模型-v1">产能预测模型 V1</h1>
<h2 id="所用数据">所用数据</h2>
<h3 id="飞机结构部件和制造工艺流程">飞机结构部件和制造工艺流程</h3>
<h4 id="飞机结构及组成">飞机结构及组成</h4>
<p>飞机主要由机体、飞机操纵系统、飞机动力装置和机载设备等部分组成，其中机体包括机翼、机身以及尾翼等部件，构成飞机的主体结构。</p>
<p align="center">
	  <img src="https://pic1.zhimg.com/80/v2-411f20aa58ad33f517b93dc877d287b0_1440w.jpg" width="600">
</p>
<ul>
<li>尾翼：使飞机具有操纵性和稳定性</li>
<li>机身：装载、传力、连接</li>
<li>发动机：产生推力</li>
<li>机翼：产生升力</li>
<li>起落架：起飞、着陆、滑跑</li>
</ul>
<h4 id="机翼的作用和组成">机翼的作用和组成</h4>
<p>机翼是飞机产生升力和<a href="https://baike.baidu.com/item/%E6%BB%9A%E8%BD%AC/7401168">滚转操纵力矩</a>的主要部件，同时也是现代飞机存储燃油的地方。</p>
<p>滚转：滚转是指飞机绕机体坐标系纵轴的旋转运动，是飞机的一种飞行状态，也称为“侧倾”。</p>
<p>机翼重量一般占全机重量的 8% - 15%，机翼结构重量占机翼重量的 30% - 50%。</p>
<p>为了更好的说明飞机制造过程，我们需要把飞机结构介绍一下。</p>
<p><strong>1. 飞机的主要部件</strong></p>
<p align="center">
	  <img src="https://pic2.zhimg.com/80/v2-e08d7876227952eceb2ce392859b90b9_1440w.jpg" width="600">
</p>
<p align="center">
	  <img src="https://pic3.zhimg.com/80/v2-dd0c21f179f8061db12c96ef4667b046_1440w.jpg" width="600">
</p>
<p align="center">
	  <img src="https://pic3.zhimg.com/80/v2-5b84a34e23c0fd22c35e57202e4d5d0e_1440w.jpg" width="600">
</p>
<p align="center">
	  <img src="https://pic1.zhimg.com/80/v2-977c20a98339c46aeba3a0b852fa8770_1440w.jpg" width="600">
</p>
 <p align="center">
	  <img src="https://pic2.zhimg.com/80/v2-1f4601a70d9b16e3b1623c62b07d50d9_1440w.jpg" width="600">
</p>
<p>机翼一般由<strong>机翼主盒、襟翼、扰流片、副翼、前缘缝翼、发动机吊挂</strong>等部分组成。</p>
<p>机身是指飞机机体结构中除各机翼结构之外的机体结构部分。</p>
<p>机身结构包括<strong>机身、短舱、尾撑</strong>等筒形结构，主要用于装载和传力，同时将机翼、尾翼、发动机和起落架等部件连接在一起，此外，可以安置空勤组人员和旅客、装载燃油、武器、各种仪器设备和货物等。</p>
 <p align="center">
	  <img src="https://pic3.zhimg.com/80/v2-2d4573edce0ccbab5dd9e64776578dda_1440w.jpg" width="600">
</p>
<p>尾翼用于保证飞机的纵向和航向的平衡与安定性，以及对飞机的操纵。</p>
<p>组成：水平尾翼（水平安定面和升降舵）和垂直尾翼（垂直安定面和方向舵）。</p>
   <p align="center">
	  <img src="https://pic1.zhimg.com/80/v2-29e2bb0d7aed5b3d25e67b921ab2b3b0_1440w.jpg" width="600">
</p>
<p>为了改善跨声速和超声速飞行器在高速飞行中的纵向操纵性，如今许多超音速飞机都将水平尾翼设计成可偏转的整体，称为全动平尾。</p>
<p>全动平尾是指整个平尾可绕某一轴线偏转，起操纵面的作用。</p>
   <p align="center">
	  <img src="https://pic1.zhimg.com/80/v2-777d437a1cdd8950ed4caa8270b4c200_1440w.jpg" width="600">
</p>
<p><strong>2. 飞机结构的划分</strong></p>
<p>像前面介绍的这种大型复杂的飞机部件，一般来说是无法直接整体制造出来的，也不便于维护。为了满足飞机的使用、维护以及生产工艺上的要求，整架飞机的机体可<strong>分解成</strong>许多大小不同的装配单元。</p>
<p><strong>飞机结构的可划分性</strong>首先取决于结构设计，即飞机结构上是否存在相应的分离面。而且划分出来的装配件，必须具有一定的工艺刚度。这是在飞机结构设计过程中应全面、周密考虑的主要问题之一，使所设计的飞机不仅能满足构造和使用上的要求，还必须同时满足生产工艺上的要求。</p>
<p align="center">
	  <img src="https://pic3.zhimg.com/80/v2-1efe1f57c8518223970dbf000c0c47a2_1440w.jpg" width="600">
</p>
  <p align="center">
	  <img src="https://pic1.zhimg.com/80/v2-080206b3e4982afa50ba426731e234d0_1440w.jpg" width="600">
</p>
  <p align="center">
	  <img src="https://pic3.zhimg.com/80/v2-828495d6e931a9f3e46ac2227998e062_1440w.jpg" width="600">
</p>
<p>飞机机体结构划分成许多装配单元后，两相邻装配单元间的对接结合处就形成了分离面。一般可分为两类：</p>
<p><strong>1）设计分离面</strong></p>
<p>设计分离面是根据构造上和使用上的要求而确定的。</p>
<p>如飞机的机翼，为便于运输和更换，需设计成独立的部件；如襟、副翼或舵面，需在机翼或安定面上作相对运动，也应把它们划分为独立的部件；又如歼击机机身后部装有发动机，为便于维修、更换，就把机身分成前、后机身两个部件。</p>
<p>设计分离面都采用可卸连接（如螺栓连接、铰链接合等），而且一般要求它们具有互换性。</p>
<p><strong>2）工艺分离面</strong></p>
<p>工艺分离面是由于生产上的需要。为了合理地满足工艺过程的要求，按部件进行工艺分解而划分出来的分离面。</p>
<p>由部件划分成的段件；以及由部件、段件再进一步划分出来的板件和组合件，这些都是工艺分离面。工艺分离面之间一般都采用不可卸连接，如铆接、胶接、焊接等，装配成部件后．这些分离面就消失了。</p>
<p><strong>工艺分离面的划分有显著的技术经济效果。</strong></p>
<p>部件划分为段件后：增加了<strong>平行装配面</strong>，可缩短装配周期；减少了复杂的部件装配型架数量；改善了装配工作的开敞性，提高装配质量。</p>
<p>部件、段件进一步划分为板件后：为<strong>提高装配工作的机械化和自动化程度</strong>创造了条件；有利于提高连接质量。</p>
<p align="center">
	  <img src="https://pic2.zhimg.com/80/v2-7ad43695fb4fa2db39d491722ff47de9_1440w.jpg" width="600">
</p>
<p><strong>3. 飞机制造工艺流程</strong></p>
<p><strong>飞机制造工艺流程设计是飞机制造过程的逆过程。<strong>制造工艺流程单元的划分与飞机制造过程正好相反，是</strong>自上而下逐层</strong>进行的。即先将飞机按工艺分离面分为较大的装配件/安装件，以它们为单元生成制造工艺流程；然后对每个这样的流程单元再次进行细化，将其分成较小的流程单元；如此下去，最后将制造工艺流程单元细化到最小的工作单元，形成具体的工作指令。</p>
<p align="center">
	  <img src="https://pic1.zhimg.com/80/v2-afa2319a6e31f41ef1c1c16b9cf594a8_1440w.jpg" width="600">
</p>
<p><strong>飞机制造工艺流程设计</strong>是生成飞机工艺信息的主要步骤之一，是工艺方案设计的主要内容，是生成详细计划和工作指令的基础。飞机制造工艺流程设计是在工程物料表（E-BOM）的基础上进行的。</p>
<p><strong>制造工艺流程设计的主要任务</strong>：按一定的规则，并综合考虑时间、场地、人力和设备等因素，将飞机的整个制造过程逐层划分成一个个制造工艺单元，使制造单元变为按一定结构形成的、随时间流动的制造工艺流程。</p>
<p><strong>制造工艺流程设计</strong>主要包括：装配工艺流程设计、工艺装备制造工艺流程设计、零件制造工艺流程设计。需要注意的是，由于飞机装配的特殊重要性（对部件精度、变形和寿命影响巨大），<strong>装配工艺流程设计反而是整个设计过程的主线</strong>。</p>
<p><em>特别提醒大家注意上面这个图，实际上很多情况下，工艺流程设计都在研究装配方案，因为飞机这种特殊的多零件、大尺寸、刚性弱的结构，装配决定了最终的精度和质量，也是基于这种考虑，我们可以再度强调一下<strong>飞机装配是飞机制造的龙头</strong>这一观点！</em></p>
<p>下图是国内常见的一种<strong>工艺设计流程</strong>（为表达清晰，略有简化）：</p>
 <p align="center">
	  <img src="https://pic4.zhimg.com/80/v2-f18388f00fc4ed47f2c6f3ab82fef5c7_1440w.jpg" width="600">
</p>
<p>其中：</p>
<p><strong>EO（工程指令）</strong>：已发的图纸进行更改的正式记录，用来描述一个更改而不更改图纸本身，EO将代替或补充图纸上的信息附加上去，EO是最新信息，并且是该图纸的一部分。是设计部门记录审签信息、提供发送和更改指示的文件，用于设计图样的签署、发送和更改。</p>
<p><strong>制造计划</strong>（有时称为装配制造计划）：对工艺流程（装配流程）站位、工作内容、工装、难点、重要协调部位、重要定位形式、标工等信息作了规定，可以说AO的份数在这里已经基本定下了。</p>
<p><strong>MPR（MASTER PARTS RECORD，主要零件状态记录）</strong>：MPR用于记录详细的零件信息并且从生产工艺计划传递给制造工艺计划和工作指令控制(WOC)的一种文件表。</p>
<p><strong>MBOM（Manufacture Bill Of material，制造物料清单）</strong>：MBOM由制造工程部门根据工程图纸和工厂加工能力分工编制而成的一个<strong>关于产品制造的装配层次、零件配套、制造分工路线和材料需求的报告</strong>，该报告准确表明产品整体构成总的需求，列出了每一零件号（包括工位、站位、AO等工艺编号）与其工艺下级装配件等相关的工艺信息。MBOM几乎和MPR同时开始编制，但真正完成却较晚，有时甚至要等FO、AO都确定才能完成。</p>
<p><strong>TO（TOOL ORDER，工装指令）</strong>：是一种由工艺部门编写的格式化的工艺文件，其中包括了对工装的工艺要求，工装设计或工装制造部门之间周转、检验、说明等信息。是一份集技术、质量、生产、成本、进度等内容的综合性管理表格。是工装项目立项、设计、制造、检验和接收的依据文件。</p>
<p><strong>FO（Fabrication Outline，制造大纲）</strong>：FO由工艺计划部门编写和发放，它为制造零件和小分组件提供必要的制造和工装信息。FO必须按最清楚的操作方法规范编写（例：成文的标准，典型实例或图解说明）。注意区分：<strong>制造指令FABRICATION ORDER (FO)</strong>: 带有变更数据的制造大纲复制本作为向制造门授权的工作指令以完成所要求的工作内容。</p>
<h3 id="什么是ao？">什么是AO？</h3>
<p><strong>AO（Assembly Outline，装配大纲）</strong>：AO是由<strong>装配工艺部门</strong>编制的<strong>生产性装配工艺文件</strong>，用以批准某一具体产品的<strong>装配</strong>任务。该产品需要一个单独的可说明的检验记录，汇编有任务说明，工程图纸及其版次，零件名称和零件号，工装要求，工序检验点以及完成一个独立的装配任务所必须的其它有关信息。区分：AO可以翻译为Assembly Order装配指令，目前很难说清两者之间的本质区别。</p>
 <p align="center">
	  <img src="https://i.bmp.ovh/imgs/2020/12/aa1bc47922d552ea.png" width="600">
</p>
<p>根据标志性 AO 的相关信息，可以看出阶段分为4段。</p>
<p>飞机部段间的装配完成，进入全机对接：（机头移入200工位，中机身移入，中后机身移入）</p>
 <p align="center">
	  <img src="https://ftp.bmp.ovh/imgs/2020/12/2c34151a45d122a1.png" width="1000">
</p>
<h2 id="模型思路">模型思路</h2>
<ul>
<li>假定两条产线（浦东、大场），架次按照架次号从小到大串行排列移动，符合节拍要求。同一产线下，前后两架次通过同一个标志性 AO 的时间差（天数）可视为当前位置该产线的速率。</li>
</ul>
<p>前后两架次之间的时间差的计算方式为：</p>
<p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">前</mi><mi mathvariant="normal">后</mi><mi mathvariant="normal">两</mi><mi mathvariant="normal">架</mi><mi mathvariant="normal">次</mi><mi mathvariant="normal">之</mi><mi mathvariant="normal">间</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">间</mi><mi mathvariant="normal">差</mi><mo>=</mo><mfrac><mrow><mi mathvariant="normal">开</mi><mi mathvariant="normal">工</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">间</mi><mi mathvariant="normal">差</mi><mo>+</mo><mi mathvariant="normal">完</mi><mi mathvariant="normal">工</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">间</mi><mi mathvariant="normal">差</mi></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">前后两架次之间的时间差 = \frac{开工时间差 + 完工时间差}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.36687em; vertical-align: 0em;"></span><span class="mord cjk_fallback">前</span><span class="mord cjk_fallback">后</span><span class="mord cjk_fallback">两</span><span class="mord cjk_fallback">架</span><span class="mord cjk_fallback">次</span><span class="mord cjk_fallback">之</span><span class="mord cjk_fallback">间</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mord cjk_fallback">差</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1.94633em; vertical-align: -0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.26033em;"><span class="" style="top: -2.314em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">2</span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.677em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord cjk_fallback">开</span><span class="mord cjk_fallback">工</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mord cjk_fallback">差</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord cjk_fallback">完</span><span class="mord cjk_fallback">工</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mord cjk_fallback">差</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.686em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></span></p>
<h3 id="异常值检测">异常值检测</h3>
<ul>
<li>非正态分布的异常值检测
<ul>
<li>孤立森林</li>
<li>局部异常因子</li>
</ul>
</li>
</ul>
<h4 id="孤立森林（isolation-forest）">孤立森林（isolation Forest）</h4>
<p>iForest （Isolation Forest）孤立森林 是一个基于Ensemble的快速异常检测方法，具有线性时间复杂度和高精准度，是符合大数据处理要求的state-of-the-art算法。其可以用于网络安全中的攻击检测，金融交易欺诈检测，疾病侦测，和噪声数据过滤等。</p>
<p>该算法的动机是对于连续数据的检测，把异常定义为“容易被孤立的离群点”，也可以理解为分布系数且离密度高的群体较远的点。用统计学来解释，在数据空间里面，分布稀疏的区域表示数据发生在此区域的概率很低，因而可以认为落在这些区域的数据是异常的。</p>
 <p align="center">
	  <img src="https://upload-images.jianshu.io/upload_images/4517099-01e49039eaa86636.png?imageMogr2/auto-orient/strip|imageView2/2/w/343/format/webp" width="400">
</p>
<p>iForest属于Non-parametric和unsupervised的方法，即不用定义数学模型也不需要有标记的训练。对于如何查找哪些点是否容易被孤立（isolated），iForest使用了一套非常高效的策略。假设我们用一个随机超平面来切割（split）数据空间（data space）, 切一次可以生成两个子空间（想象拿刀切蛋糕一分为二）。之后我们再继续用一个随机超平面来切割每个子空间，循环下去，直到每子空间里面只有一个数据点为止。直观上来讲，我们可以发现那些密度很高的簇是可以被切很多次才会停止切割，但是那些密度很低的点很容易很早的就停到一个子空间了。上图里面黑色的点就很容易被切几次就停到一个子空间，而白色点聚集的地方可以切很多次才停止。</p>
<p>怎么来切这个数据空间是iForest的设计核心思想，本文仅介绍最基本的方法。由于切割是随机的，所以需要用ensemble的方法来得到一个收敛值（蒙特卡洛方法），即反复从头开始切，然后平均每次切的结果。iForest 由t个iTree（Isolation Tree）孤立树 组成，每个iTree是一个二叉树结构，其实现步骤如下：</p>
<p>孤立森林其实也是随机森林的一种变体，其实简单来说随机森林是一种bagging算法，也就是在于随机采样！</p>
<p>随机采样（bootstrap）是从我们的训练集里面<strong>有放回</strong>的采集固定个数的样本，一般采集和训练样本数 m 一样个数的样本。这样得到的采样集和训练集样本的个数相同，但是样本内容不同。</p>
<p align="center">
	  <img src="https://images2015.cnblogs.com/blog/1042406/201612/1042406-20161204200000787-1988863729.png
" width="800">
</p>
<p><img src="https://i.bmp.ovh/imgs/2020/12/a6ab9353f457f435.png" alt=""></p>
<p>bagging的集合策略也比较简单，对于分类问题，通常使用简单投票法，得到最多票数的类别或者类别之一为最终的模型输出。对于回归问题，通常使用简单平均法，对T个弱学习器得到的回归结果进行算术平均得到最终的模型输出。</p>
<p>由于bagging算法每次<strong>都进行采样</strong>来训练模型，因此泛化能力很强，对于<strong>降低模型的方差</strong>很有作用。当然对于训练集的拟合程度就会差一些，也就是模型的bias会大一些（underfitting）</p>
<p>输入为样本集 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mo>=</mo><mo stretchy="false">{</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>m</mi></msub><mo separator="true">,</mo><msub><mi>y</mi><mi>m</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">D=\{(x_1,y_1),(x_2,y_2),...(x_m,y_m)\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">D</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">{</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">}</span></span></span></span></span>，弱学习器算法，弱分类器迭代次数T。</p>
<p>输出为最终的强分类器f(x)f(x)</p>
<ol>
<li>对于 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">t=1,2,...,T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.61508em; vertical-align: 0em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.87777em; vertical-align: -0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span></span></span></span></span>:</li>
</ol>
<p>a. 对训练集进行第 t 次随机采样，共采集 m 次，得到包含 m 个样本的采样集 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>D</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">D_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.280556em;"><span class="" style="top: -2.55em; margin-left: -0.02778em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span></p>
<p>b. 用采样集<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>D</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">D_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.280556em;"><span class="" style="top: -2.55em; margin-left: -0.02778em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>训练第 t 个弱学习器<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>G</mi><mi>t</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G_t(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathdefault">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.280556em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span></span></p>
<ol start="2">
<li>如果是分类算法预测，则T个弱学习器投出最多票数的类别或者类别之一为最终类别。如果是回归算法，T个弱学习器得到的回归结果进行算术平均得到的值为最终的模型输出。</li>
</ol>
<p>那么随机森林算法也就是 RF，就是其进化版，首先其使用了 CART 决策树来作为弱分类器，我们基于普通决策树做了改进，通过选择节点上的一部分样本特征一般是 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>n</mi><mrow><mi>s</mi><mi>u</mi><mi>b</mi></mrow></msub><mo>=</mo><msqrt><mi>n</mi></msqrt></mrow><annotation encoding="application/x-tex">n_{sub } = \sqrt{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1.04em; vertical-align: -0.23972em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.80028em;"><span class="svg-align" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord" style="padding-left: 0.833em;"><span class="mord mathdefault">n</span></span></span><span class="" style="top: -2.76028em;"><span class="pstrut" style="height: 3em;"></span><span class="hide-tail" style="min-width: 0.853em; height: 1.08em;"><svg width="400em" height="1.08em" viewBox="0 0 400000 1080" preserveAspectRatio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.23972em;"><span class=""></span></span></span></span></span></span></span></span></span> 个特征来选择最优特征来划分子树，进一步增加了泛化能力。</p>
<p>当 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>n</mi><mrow><mi>s</mi><mi>u</mi><mi>b</mi></mrow></msub></mrow><annotation encoding="application/x-tex">n_{sub}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 越小时，模型越 robust，此时方差会减小，但是偏差会增大，这个 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>n</mi><mrow><mi>s</mi><mi>u</mi><mi>b</mi></mrow></msub></mrow><annotation encoding="application/x-tex">n_{sub}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 一般用交叉验证来选取。</p>
<p>那么了解到这里，Isolation Forest 就是类似于 RF 的方法来检查异常点，对于在 T 个决策树的样本集，IForest 也会对训练集进行随机采样，但是采样个数不需要和 RF 一样（<strong>也就是不需要使得采样集样本数等于训练集个数</strong>），甚至要<font color="red">远远小于</font>训练集个数，因为我们的目的是异常点检测，只需要部分的样本我们一般就可以将异常点区别出来。</p>
<p>对于每一个决策树的建立， IForest采用随机选择一个划分特征，对划分特征随机选择一个划分阈值。这点也和 RF 不同。</p>
<p>另外，IForest一般会选择一个比较小的最大决策树深度max_depth,原因同样本采集，用少量的异常点检测一般不需要这么大规模的决策树。</p>
<p>对于异常点的判断，则是将测试样本点xx拟合到T颗决策树。计算在每颗决策树上该样本的叶子节点的深度 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>h</mi><mi>t</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h_t(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.280556em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span></span>。，从而可以计算出平均高度 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span></span>。获得 t 个 iTree 之后，iForest 训练就结束，然后我们可以用生成的 iForest 来评估测试数据了。对于一个训练数据 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">x</span></span></span></span></span>，我们令其遍历每一棵iTree，然后计算x最终落在每个树第几层（<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">x</span></span></span></span></span> 在树的高度）。值得注意的是，如果x落在一个节点中含多个训练数据，可以使用一个公式来修正x的高度计算，详细公式推导见<a href="https://link.jianshu.com/?t=http%3A%2F%2Fcs.nju.edu.cn%2Fzhouzh%2Fzhouzh.files%2Fpublication%2Ficdm08b.pdf">原论文</a>。</p>
 <p align="center">
	  <img src="https://i.bmp.ovh/imgs/2020/12/c555e849406cef73.png" width="700">
</p>
<p>此时我们用下面的公式计算样本点 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">x</span></span></span></span></span> 的异常概率:</p>
<p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mn>2</mn><mrow><mi mathvariant="normal">−</mi><mfrac><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><mrow><mi>c</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow></msup></mrow><annotation encoding="application/x-tex">s(x,m)=2^{−\frac{h(x)}{c(m)}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1.21065em; vertical-align: 0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 1.21065em;"><span class="" style="top: -3.4842em; margin-right: 0.05em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.03779em;"><span class="" style="top: -2.64079em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">m</span><span class="mclose mtight">)</span></span></span></span><span class="" style="top: -3.2255em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line mtight" style="border-bottom-width: 0.049em;"></span></span><span class="" style="top: -3.50207em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.537786em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>其中，m 为样本个数。<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">c(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">c</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span></span> 的表达式为：</p>
<p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn><mi>ln</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>m</mi><mi mathvariant="normal">−</mi><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>ξ</mi><mi mathvariant="normal">−</mi><mn>2</mn><mfrac><mrow><mi>m</mi><mi mathvariant="normal">−</mi><mn>1</mn></mrow><mi>m</mi></mfrac><mo separator="true">,</mo><mtext>&nbsp;</mtext><mi>ξ</mi><mi mathvariant="normal">为</mi><mi mathvariant="normal">欧</mi><mi mathvariant="normal">拉</mi><mi mathvariant="normal">常</mi><mi mathvariant="normal">数</mi></mrow><annotation encoding="application/x-tex">c(m)=2\ln(m−1)+ξ−2\frac{m−1}{m},\ ξ为欧拉常数</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">c</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">2</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mop">ln</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 2.00744em; vertical-align: -0.686em;"></span><span class="mord mathdefault" style="margin-right: 0.04601em;">ξ</span><span class="mord">−</span><span class="mord">2</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.32144em;"><span class="" style="top: -2.314em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault">m</span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.677em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="mord">−</span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.686em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mspace">&nbsp;</span><span class="mord mathdefault" style="margin-right: 0.04601em;">ξ</span><span class="mord cjk_fallback">为</span><span class="mord cjk_fallback">欧</span><span class="mord cjk_fallback">拉</span><span class="mord cjk_fallback">常</span><span class="mord cjk_fallback">数</span></span></span></span></span></span></p>
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">s(x,m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span></span> 的取值范围是 [0,1] ,取值越接近于1，则是异常点的概率也越大。</p>
<p>算法本身并不复杂，主要包括</p>
<p><strong>第一步</strong>：训练构建随机森林对应的多颗决策树，这些决策树一般叫 iTree</p>
<p><strong>第二步</strong>：计算需要检测的数据点xx最终落在任意第 t 颗 iTree 的层数 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>h</mi><mi>t</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h_t(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.280556em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span></span>。然后我们可以得出 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">x</span></span></span></span></span> 在每棵树的高度平均值 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span></span>。第三步根据<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span></span>判断 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">x</span></span></span></span></span> 是否是异常点。</p>
<p>在sklearn中，我们可以用 ensemble 包里面的IsolationForest来做异常点检测。</p>
<p><font color="red"><strong>具体如下：</strong></font></p>
<p>2.7. 新奇点和离群点检测：<a href="https://sklearn.apachecn.org/docs/master/26.html">https://sklearn.apachecn.org/docs/master/26.html</a></p>
<p>sklearn 应用</p>
<p>IForest 算法返回每个使用 IForest 算法的样本的异常分数。 通过随机选择一个特征然后随机选择一个在被选中的特征的的最值之间的一个分割值来进行异常值检测。</p>
<p>随机分区产生的异常路径明显较短。因此，当随机树木的森林为特定样本共同产生较短的路径长度时，它们很可能是异常的。</p>
<p>iForest算法默认参数设置如下：</p>
<pre class=" language-python"><code class="prism  language-python">subsample size <span class="token operator">=</span> <span class="token number">256</span>

Tree height <span class="token operator">=</span> <span class="token number">8</span>

Number of trees <span class="token operator">=</span> <span class="token number">100</span>
</code></pre>
<p>通俗解释就是——建100棵iTree，每棵iTree最高8层，且每棵iTree都是独立随机选择256个数据样本建成。</p>
<p><strong>个人理解：</strong></p>
<ol>
<li>
<p><strong>IForest 具有线性时间复杂度。</strong> 因为是ensemble 的方法，所以可以用在含有<em>海量数据</em>的数据集上面。通常树的数量越多，算法越稳定。由于每棵树都是互相独立生成的，因此可以部署在大规模分布式系统上来加速运算。</p>
</li>
<li>
<p>IForest不适用于特别高维的数据。由于每次切数据空间都是随机选取一个维度，建完树后仍然有大量的维度信息没有被使用，导致算法可靠性降低。高维空间还可能存在大量噪音维度或无关维度（irrelevant attributes），影响树的构建。对这类数据，建议使用子空间异常检测（Subspace Anomaly Detection）技术。</p>
</li>
<li>
<p><strong>IForest仅对Global Anomaly 敏感，即全局稀疏点敏感，不擅长处理局部的相对稀疏点 （Local Anomaly）。</strong> 目前已有改进方法发表于 PAKDD，详见“<a href="https://link.jianshu.com?t=http%3A%2F%2Flink.springer.com%2Fchapter%2F10.1007%2F978-3-319-06605-9_42">Improving iForest with Relative Mass</a>”。</p>
</li>
<li>
<p>IForest推动了重心估计（Mass Estimation）理论发展，目前在分类聚类和异常检测中都取得显著效果，发表于各大顶级数据挖掘会议和期刊（如SIGKDD，ICDM，ECML）。</p>
</li>
</ol>
<p><strong>论文下载</strong>：</p>
<p><a href="https://link.jianshu.com?t=http%3A%2F%2Fcs.nju.edu.cn%2Fzhouzh%2Fzhouzh.files%2Fpublication%2Ficdm08b.pdf">http://cs.nju.edu.cn/zhouzh/zhouzh.files/publication/icdm08b.pdf</a></p>
<p><a href="https://link.jianshu.com?t=http%3A%2F%2Fcs.nju.edu.cn%2Fzhouzh%2Fzhouzh.files%2Fpublication%2Ftkdd11.pdf">http://cs.nju.edu.cn/zhouzh/zhouzh.files/publication/tkdd11.pdf</a></p>
<p><strong>源码下载</strong>：</p>
<p>R语言 <a href="https://link.jianshu.com?t=https%3A%2F%2Fsourceforge.net%2Fprojects%2Fiforest%2F">https://sourceforge.net/projects/iforest/</a></p>
<p>Python语言 <a href="https://link.jianshu.com?t=http%3A%2F%2Fscikit-learn.org%2Fstable%2Fmodules%2Fgenerated%2Fsklearn.ensemble.IsolationForest.html">http://scikit-learn.org/stable/modules/generated/sklearn.ensemble.IsolationForest.html</a></p>
</div>
</body>

</html>
