<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>sql</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__html"><p align="center">
	  <img src="https://thumbs.gfycat.com/InsistentSardonicAppaloosa-small.gif">
</p>
<h1 id="sql刷题">SQL刷题</h1>
<h2 id="题目">题目</h2>
<h3 id="easy">Easy</h3>
<ol>
<li><a href="#1">Actors and Directors Who Cooperated At Least Three Times</a></li>
<li><a href="#2">Ads Performance</a></li>
<li><a href="#3">Article Views I</a></li>
<li><a href="#4">Average Selling Price</a></li>
<li><a href="#5">Biggest Single Number</a></li>
<li><a href="#6">Combine Two Tables</a></li>
<li><a href="#7">Consecutive Available Seats</a></li>
<li><a href="#8">Customer Order Frequency</a></li>
<li><a href="#9">Customer Placing the Largest Number of Orders</a></li>
<li><a href="#10">Customers Who Never Order</a></li>
<li><a href="#11">Delete Duplicate Emails</a></li>
<li><a href="#12">Duplicate Emails</a></li>
</ol>
<h3 id="span-id11.-actors-and-directors-who-cooperated-at-least-three-timesspan"><span id="1">1. Actors and Directors Who Cooperated At Least Three Times</span></h3>
<p>注意到，这里的table: <code>ActorDirector</code> 包含三列，其中timestamp是<a href="https://www.liaoxuefeng.com/wiki/1177760294764384/1218728391867808">主键</a>。</p>
<p>我们需要找到所有的配对（actor_id, director_id）其中演员和导演合作过至少三次。</p>
<p>所以，我们要求<code>actor_id</code>和<code>director_id</code>配对的数量不小于三，<br>
利用<code>count</code>函数我们有：</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">select</span> actor_id<span class="token punctuation">,</span> director_id<span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">as</span> counts
<span class="token keyword">from</span> actordirector
<span class="token keyword">group</span> <span class="token keyword">by</span> actor_id<span class="token punctuation">,</span> director_id
</code></pre>
<p>这一步的结果如下，我们对应每个演员、导演并且计算出他们合作的次数，分别为3，2，2。</p>
<p><code>{"headers": ["actor_id", "director_id", "c"], "values": [[1, 1, 3], [1, 2, 2], [2, 1, 2]]}</code></p>
<p>如果不清楚<code>group by</code>可以看<a href="https://www.w3schools.com/sql/sql_groupby.asp">这里</a>。</p>
<p>还有，我们可以用<code>group by 1,2</code>来代替<code>group by actor_id, director_id</code>，其实1和2代表的就是<code>select</code>前两列的意思。</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">select</span> actor_id<span class="token punctuation">,</span> director_id<span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">as</span> counts
<span class="token keyword">from</span> actordirector
<span class="token keyword">group</span> <span class="token keyword">by</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span>
</code></pre>
<p>接下来，我们只需在这个基础上找到所有的演员和导演满足<code>counts &gt;= 3</code>即可。</p>
<p><font color="red">最终答案如下：</font></p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">select</span> actor_id<span class="token punctuation">,</span> director_id <span class="token keyword">from</span>
<span class="token punctuation">(</span><span class="token keyword">select</span> actor_id<span class="token punctuation">,</span> director_id<span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">as</span> counts
<span class="token keyword">from</span> actordirector
<span class="token keyword">group</span> <span class="token keyword">by</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> tmp
<span class="token keyword">where</span> counts <span class="token operator">&gt;=</span> <span class="token number">3</span>
</code></pre>
<p>这里使用了十分常见的<a href="https://www.1keydata.com/cn/sql/sql-subquery.php">subquery</a>，其中注意要在table后面加上别名（alias），这里用tmp表示</p>
<p align="center">
	  <img src="https://github.com/zg104/zg104.github.io/blob/master/image/sql1.png?raw=true">
</p>
<h3 id="span-id22.-ads-performancespan"><span id="2">2. Ads Performance</span></h3>
<p>注意，<code>Ads</code>表里面<code>ad_id</code>和<code>user_id</code>是主键，我们需要按照给出的公式算出CTR。</p>
<p>所以根据每个<code>ad_id</code>，我们可以计算出其对应的<code>Clicked</code>和<code>Viewed</code>的个数，在利用公式可求得CTR。</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">select</span> ad_id<span class="token punctuation">,</span>
<span class="token comment"># case when类似于if else语句，表示当action = 'Clicked'记为1，否则记为0,注意一定后面加上end！用sum函数计算每个不同的ad_id对应的Clicked的总数，同理用其除以后面的式子，得到ctr，并用round函数保留两位小数</span>
	<span class="token function">round</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token operator">*</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">case</span> <span class="token keyword">when</span> <span class="token keyword">action</span> <span class="token operator">=</span> <span class="token string">'Clicked'</span> <span class="token keyword">then</span> <span class="token number">1</span> <span class="token keyword">else</span> <span class="token number">0</span> <span class="token keyword">end</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">case</span> <span class="token keyword">when</span> <span class="token keyword">action</span> <span class="token operator">=</span> <span class="token string">'Clicked'</span> <span class="token operator">or</span> <span class="token keyword">action</span> <span class="token operator">=</span> <span class="token string">'Viewed'</span> <span class="token keyword">then</span> <span class="token number">1</span> <span class="token keyword">else</span> <span class="token number">0</span> <span class="token keyword">end</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">as</span> ctr
<span class="token keyword">from</span> ads
<span class="token keyword">group</span> <span class="token keyword">by</span> ad_id <span class="token comment"># 对应每个不同的ad_id</span>
<span class="token keyword">order</span> <span class="token keyword">by</span> ctr <span class="token keyword">desc</span><span class="token punctuation">,</span> ad_id <span class="token keyword">asc</span><span class="token punctuation">;</span> <span class="token comment"># 排序</span>
</code></pre>
<p>结果如下：</p>
<p><code>{"headers": ["ad_id", "ctr"], "values": [[1, 66.67], [3, 50.00], [2, 33.33], [5, null]]}</code></p>
<p>我们发现，当<code>ad_id</code>等于<code>5</code>，ctr为<code>null</code>而不是<code>0.00</code>。所以我们需要对这种情况做些调整，用<code>ifnull</code>函数把<code>null</code>转换成<code>0</code>。</p>
<p><font color="red">最终答案如下：</font></p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token comment"># case when类似于if else语句，表示当action = 'Clicked'记为1，否则记为0,注意一定后面加上end！用sum函数计算每个不同的ad_id对应的Clicked的总数，同理用其除以后面的式子，得到ctr，并用round函数保留两位小数，且用ifnull函数处理缺失值。</span>
<span class="token keyword">select</span> ad_id<span class="token punctuation">,</span>
	ifnull<span class="token punctuation">(</span><span class="token function">round</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token operator">*</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">case</span> <span class="token keyword">when</span> <span class="token keyword">action</span> <span class="token operator">=</span> <span class="token string">'Clicked'</span> <span class="token keyword">then</span> <span class="token number">1</span> <span class="token keyword">else</span> <span class="token number">0</span> <span class="token keyword">end</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">case</span> <span class="token keyword">when</span> <span class="token keyword">action</span> <span class="token operator">=</span> <span class="token string">'Clicked'</span> <span class="token operator">or</span> <span class="token keyword">action</span> <span class="token operator">=</span> <span class="token string">'Viewed'</span> <span class="token keyword">then</span> <span class="token number">1</span> <span class="token keyword">else</span> <span class="token number">0</span> <span class="token keyword">end</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">as</span> ctr
<span class="token keyword">from</span> ads
<span class="token keyword">group</span> <span class="token keyword">by</span> ad_id <span class="token comment"># 对应每个不同的ad_id</span>
<span class="token keyword">order</span> <span class="token keyword">by</span> ctr <span class="token keyword">desc</span><span class="token punctuation">,</span> ad_id <span class="token keyword">asc</span><span class="token punctuation">;</span> <span class="token comment"># 排序</span>
</code></pre>
<p align="center">
	  <img src="https://github.com/zg104/zg104.github.io/blob/master/image/sql2.png?raw=true">
</p>
<h3 id="span-id33.-article-views-ispan"><span id="3">3. Article Views I</span></h3>
<p>Table:  <code>Views</code></p>
<p>±--------------±--------+<br>
| Column Name   | Type    |<br>
±--------------±--------+<br>
| article_id    | int     |<br>
| author_id     | int     |<br>
| viewer_id     | int     |<br>
| view_date     | date    |<br>
±--------------±--------+<br>
注意这里没有主键，说明可能会含有重复的行，每一行表示某个观看者在某个日期观看了某个作者写的某篇文章。</p>
<p><strong>我们要找出所有的观看了至少一篇自己的文章的作者，并且按照他们的id的升序排序。</strong></p>
<p>Views table:<br>
±-----------±----------±----------±-----------+<br>
| article_id | author_id | viewer_id | view_date  |<br>
±-----------±----------±----------±-----------+<br>
| 1          | 3         | 5         | 2019-08-01 |<br>
| 1          | 3         | 6         | 2019-08-02 |<br>
| 2          | 7         | 7         | 2019-08-01 |<br>
| 2          | 7         | 6         | 2019-08-02 |<br>
| 4          | 7         | 1         | 2019-07-22 |<br>
| 3          | 4         | 4         | 2019-07-21 |<br>
| 3          | 4         | 4         | 2019-07-21 |<br>
±–±—±---±--------------+</p>
<p>Result table:<br>
±-----+<br>
| id   |<br>
±-----+<br>
| 4    |<br>
| 7    |<br>
±-----+</p>
<p><font color="red">正确答案如下：</font></p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">select</span> <span class="token keyword">distinct</span> author_id <span class="token keyword">as</span> <span class="token string">'id'</span>
<span class="token keyword">from</span> views
<span class="token keyword">where</span> author_id <span class="token operator">=</span> viewer_id
<span class="token keyword">order</span> <span class="token keyword">by</span> <span class="token number">1</span>

<span class="token comment"># 注意</span>
<span class="token comment"># 1. distinct 函数筛选出了唯一的auther_id，因为可能有重复的行存在</span>
<span class="token comment"># 2. order by 1 = order by author_id</span>
</code></pre>
<p align="center">
	  <img src="https://github.com/zg104/zg104.github.io/blob/master/image/sql3.png?raw=true">
</p>
<h3 id="span-id44.-average-selling-pricespan"><span id="4">4. Average Selling Price</span></h3>
<p>Table: <code>Prices</code><br>
±--------------±--------+<br>
| Column Name   | Type    |<br>
±--------------±--------+<br>
| product_id    | int     |<br>
| start_date    | date    |<br>
| end_date      | date    |<br>
| price         | int     |<br>
±--------------±--------+</p>
<p>这里的 <code>product_id</code>、<code>start_date</code>和 <code>end_date</code> 都是主键，每一行表示了在开始日期到结束日期内的每个 <code>product_id</code> 的价格，并且对于一个 <code>product_id</code>，不会有两个相交的时间区间存在。</p>
<p>Table:  <code>UnitsSold</code><br>
±--------------±--------+<br>
| Column Name   | Type    |<br>
±--------------±--------+<br>
| product_id    | int     |<br>
| purchase_date | date    |<br>
| units         | int     |<br>
±--------------±--------+</p>
<p>这里没有主键，所以有重复的行，每一行表示对于每个卖出的产品的 <code>product_id</code>、<code>purchase_date</code> 和 <code>units</code>。</p>
<p><strong>我们需要找到每个产品的平均售卖价格。</strong></p>
<p>例如：</p>
<p>Prices table:<br>
±-----------±-----------±-----------±-------+<br>
| product_id | start_date | end_date   | price  |<br>
±-----------±-----------±-----------±-------+<br>
| 1          | 2019-02-17 | 2019-02-28 | 5      |<br>
| 1          | 2019-03-01 | 2019-03-22 | 20     |<br>
| 2          | 2019-02-01 | 2019-02-20 | 15     |<br>
| 2          | 2019-02-21 | 2019-03-31 | 30     |<br>
±-----------±-----------±-----------±-------+</p>
<p>UnitsSold table:<br>
±-----------±--------------±------+<br>
| product_id | purchase_date | units |<br>
±-----------±--------------±------+<br>
| 1          | 2019-02-25    | 100   |<br>
| 1          | 2019-03-01    | 15    |<br>
| 2          | 2019-02-10    | 200   |<br>
| 2          | 2019-03-22    | 30    |<br>
±-----------±--------------±------+</p>
<p>Result table:<br>
±-----------±--------------+<br>
| product_id | average_price |<br>
±-----------±--------------+<br>
| 1          | 6.96          |<br>
| 2          | 16.96         |<br>
±-----------±--------------+<br>
Average selling price = Total Price of Product / Number of products sold.<br>
Average selling price for product <code>1 = ((100 * 5) + (15 * 20)) / 115 = 6.96</code><br>
Average selling price for product <code>2 = ((200 * 15) + (30 * 30)) / 230 = 16.96</code></p>
<p><font color="red">正确答案如下：</font></p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">select</span> p<span class="token punctuation">.</span>product_id<span class="token punctuation">,</span> <span class="token function">round</span><span class="token punctuation">(</span><span class="token function">sum</span><span class="token punctuation">(</span>price<span class="token operator">*</span>units<span class="token punctuation">)</span><span class="token operator">/</span><span class="token function">sum</span><span class="token punctuation">(</span>units<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">as</span> average_price
<span class="token keyword">from</span> prices <span class="token keyword">as</span> p
<span class="token keyword">join</span> unitssold <span class="token keyword">as</span> u
<span class="token keyword">using</span> <span class="token punctuation">(</span>product_id<span class="token punctuation">)</span>
<span class="token keyword">where</span> u<span class="token punctuation">.</span>purchase_date <span class="token operator">between</span> p<span class="token punctuation">.</span>start_date <span class="token operator">and</span> p<span class="token punctuation">.</span>end_date
<span class="token keyword">group</span> <span class="token keyword">by</span> p<span class="token punctuation">.</span>product_id

<span class="token comment"># 注意</span>
<span class="token comment"># 1. 对于table要加上alias，并且对于公共的product_id要加上对应的table名</span>
<span class="token comment"># 2. using (product_id) 等价于 on p.product_id = u.product_id</span>
<span class="token comment"># 3. 要保证purchase_date在start_date和end_date中间，可能会被忽略，并且这个条件要在group by之前，因为在aggregate之前我们要筛选出满足时间范围的行，在进行计算！</span>
</code></pre>
<p align="center">
	  <img src="https://github.com/zg104/zg104.github.io/blob/master/image/sql4.png?raw=true">
</p>
<h3 id="span-id55.-biggest-single-numberspan"><span id="5">5. Biggest Single Number</span></h3>
<p>Table  <code>my_numbers</code>  contains many numbers in column  <strong>num</strong>  including duplicated ones.<br>
Can you write a SQL query to find the biggest number, which only appears once.</p>
<p>±–+<br>
|num|<br>
±–+<br>
| 8 |<br>
| 8 |<br>
| 3 |<br>
| 3 |<br>
| 1 |<br>
| 4 |<br>
| 5 |<br>
| 6 |</p>
<p>For the sample data above, your query should return the following result:</p>
<p>±–+<br>
|num|<br>
±–+<br>
| 6 |</p>
<p><strong>Note:</strong><br>
If there is no such number, just output <strong>null</strong>.</p>
<p>那么我们要找的就是num里面只出现一次的最大的数</p>
<p>可能你会这么写</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">select</span> <span class="token function">max</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token string">'num'</span>
<span class="token keyword">from</span> my_number
<span class="token keyword">group</span> <span class="token keyword">by</span> num
<span class="token keyword">having</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1</span>
</code></pre>
<p>但这样会返回错误的值，如下：</p>
<p><code>{"headers": ["num"], "values": [[1], [4], [5], [6]]}</code></p>
<p>我们是找出了出现次数为1的数字但是max函数貌似不起作用，因为这里的<code>max(num)</code>针对的是num，相当于对每一个group by的数字都取了最大值，也就是本身，所以无效</p>
<p><font color="red">正确答案如下：</font></p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">select</span> <span class="token function">max</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token keyword">as</span> num
<span class="token keyword">from</span>
<span class="token punctuation">(</span><span class="token keyword">select</span>
    num
<span class="token keyword">from</span>
    my_numbers
<span class="token keyword">group</span> <span class="token keyword">by</span> num
<span class="token keyword">having</span> <span class="token function">count</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">as</span> tmp
<span class="token comment"># 使用subquery对所有出现次数为1的数字取最大值</span>
</code></pre>
<p>或者</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">select</span> <span class="token function">max</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token keyword">as</span> num
<span class="token keyword">from</span>
<span class="token punctuation">(</span><span class="token keyword">select</span>
    num<span class="token punctuation">,</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">as</span> counts
<span class="token keyword">from</span>
    my_numbers
<span class="token keyword">group</span> <span class="token keyword">by</span> num<span class="token punctuation">)</span> <span class="token keyword">as</span> tmp
<span class="token keyword">where</span> counts <span class="token operator">=</span> <span class="token number">1</span>
</code></pre>
<p align="center">
	  <img src="https://github.com/zg104/zg104.github.io/blob/master/image/sql5.png?raw=true">
</p>
<h3 id="span-id66.-combine-two-tablesspan"><span id="6">6. Combine Two Tables</span></h3>
<p>Table:  <code>Person</code></p>
<p>±------------±--------+<br>
| Column Name | Type    |<br>
±------------±--------+<br>
| PersonId    | int     |<br>
| FirstName   | varchar |<br>
| LastName    | varchar |<br>
±------------±--------+<br>
PersonId is the primary key column for this table.</p>
<p>Table:  <code>Address</code></p>
<p>±------------±--------+<br>
| Column Name | Type    |<br>
±------------±--------+<br>
| AddressId   | int     |<br>
| PersonId    | int     |<br>
| City        | varchar |<br>
| State       | varchar |<br>
±------------±--------+<br>
AddressId is the primary key column for this table.</p>
<p>Write a SQL query for a report that provides the following information for each person in the Person table, regardless if there is an address for each of those people:</p>
<p><code>FirstName, LastName, City, State</code></p>
<p>这个题看似很简单，只需要把他们合并起来就可以了，但是要注意<code>inner join</code>和<code>left join</code>的区别（<code>right join</code>其实和<code>left join</code>是一回事）。</p>
<p>一图流！</p>
<p align="center">
	  <img src="https://i.stack.imgur.com/fzwkg.png">
</p>
<p>这里题目要求我们找出每个人的各种信息，无论这个人是不是有地址，也就是哪怕没有地址，也要用<code>null</code>表示，那自然要用<code>left join</code>。</p>
<p><font color="red">正确答案如下：</font></p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">select</span> FirstName<span class="token punctuation">,</span> LastName<span class="token punctuation">,</span> City<span class="token punctuation">,</span> State
<span class="token keyword">from</span> Person <span class="token keyword">left</span> <span class="token keyword">join</span> Address
<span class="token keyword">on</span> Person<span class="token punctuation">.</span>PersonId <span class="token operator">=</span> Address<span class="token punctuation">.</span>PersonId
<span class="token comment"># using (PersonId)</span>
</code></pre>
<p>结果如下：</p>
<p><code>{"headers": ["FirstName", "LastName", "City", "State"], "values": [["Allen", "Wang", null, null]]}</code></p>
<p align="center">
	  <img src="https://github.com/zg104/zg104.github.io/blob/master/image/sql6.png?raw=true">
</p>
<h3 id="span-id77.-consecutive-available-seatsspan"><span id="7">7. Consecutive Available Seats</span></h3>
<p>Several friends at a cinema ticket office would like to reserve consecutive available seats.<br>
Can you help to query all the consecutive available seats order by the seat_id using the following <code>cinema</code> table?</p>

<table>
<thead>
<tr>
<th>seat_id</th>
<th>free</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>0</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
</tr>
<tr>
<td>4</td>
<td>1</td>
</tr>
<tr>
<td>5</td>
<td>1</td>
</tr>
</tbody>
</table><p>Your query should return the following result for the sample case above.</p>

<table>
<thead>
<tr>
<th>seat_id</th>
</tr>
</thead>
<tbody>
<tr>
<td>3</td>
</tr>
<tr>
<td>4</td>
</tr>
<tr>
<td>5</td>
</tr>
</tbody>
</table><p><strong>Note</strong>:</p>
<ul>
<li>The seat_id is an auto increment int, and free is bool (‘1’ means free, and ‘0’ means occupied.).</li>
<li>Consecutive available seats are more than 2(inclusive) seats consecutively available.</li>
</ul>
<p>我们要找到连续挨着的并且是可以坐的（available）的<code>seat_id</code>，并按照其升序排序。</p>
<p>感觉不是那么简单对吧，这里要用到<code>cross join</code>。</p>
<p>一图流！</p>
<p align="center">
	  <img src="https://cdn.sqlservertutorial.net/wp-content/uploads/SQL-Server-CROSS-JOIN-example.png">
</p>
<p>所谓<code>cross join</code>也就是两个表格的<a href="https://zh.wikipedia.org/wiki/%E7%AC%9B%E5%8D%A1%E5%84%BF%E7%A7%AF">笛卡尔积</a>，是我们很常用的手段之一。那么如果这个table有5行，那么在经过跟自己本身<code>cross join</code>之后，就会变成一个<code>5 x 5</code>的table，我们要找的就是 table A 和 table B（<strong>当然，他们其实是同一个table，只不过名称不同</strong>）的满足下列两个条件的<code>seat_id</code>：</p>
<ul>
<li>在 A 和 B 中都满足<code>free = 1</code>，因为我们要满足 available。</li>
<li><code>seat_id</code>是连续的，也就是他们差的绝对值是等于1的</li>
</ul>
<p><font color="red">正确答案如下：</font></p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">select</span> <span class="token keyword">distinct</span> <span class="token number">a</span><span class="token punctuation">.</span>seat_id
<span class="token keyword">from</span> cinema <span class="token number">a</span><span class="token punctuation">,</span> cinema <span class="token number">b</span>
<span class="token keyword">where</span> abs<span class="token punctuation">(</span><span class="token number">a</span><span class="token punctuation">.</span>seat_id <span class="token operator">-</span> <span class="token number">b</span><span class="token punctuation">.</span>seat_id<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1</span>
<span class="token operator">and</span> <span class="token number">a</span><span class="token punctuation">.</span>free <span class="token operator">=</span> <span class="token number">1</span>
<span class="token operator">and</span> <span class="token number">b</span><span class="token punctuation">.</span>free <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">order</span> <span class="token keyword">by</span> <span class="token number">1</span>
<span class="token comment"># 直接使用 select from table A, table B 这种语法其实就是cross join，不要以为你没有用join，其实这就是和cross join等价的！</span>
</code></pre>
<p>或者</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">select</span> <span class="token keyword">distinct</span> <span class="token number">a</span><span class="token punctuation">.</span>seat_id
<span class="token keyword">from</span> cinema <span class="token number">a</span>
<span class="token keyword">join</span> cinema <span class="token number">b</span>
	<span class="token keyword">on</span> abs<span class="token punctuation">(</span><span class="token number">a</span><span class="token punctuation">.</span>seat_id <span class="token operator">-</span> <span class="token number">b</span><span class="token punctuation">.</span>seat_id<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1</span>
	<span class="token operator">and</span> <span class="token number">a</span><span class="token punctuation">.</span>free <span class="token operator">=</span> <span class="token number">1</span> 
	<span class="token operator">and</span> <span class="token number">b</span><span class="token punctuation">.</span>free <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">order</span> <span class="token keyword">by</span> <span class="token number">1</span>
<span class="token comment"># 这个就是self join的一般写法！</span>
</code></pre>
<p>我估计你可能还是没太明白<code>self join</code>的含义，这个题是属于<code>cross join</code>的题，但也属于<code>self join</code>，因为table是和自己本身<code>cross join</code>的，但是<code>cross join</code>不局限于自己和自己本身去 join，下面这个链接会帮你更好的理解<code>self join</code>!</p>
<p>补充资料：</p>
<ul>
<li><a href="https://stackoverflow.com/questions/3362038/what-is-self-join-and-when-would-you-use-it#:~:text=You%20use%20a%20self%20join,boss%20of%20the%20current%20employee.&amp;text=It's%20basically%20used%20where%20there,stored%20in%20the%20same%20table.">什么是 self join 以及什么时候使用它？</a></li>
<li><a href="https://towardsdatascience.com/take-your-sql-skills-to-the-next-level-by-understanding-the-self-join-75f1d52f2322">self join 详细讲解</a></li>
</ul>
<p align="center">
	  <img src="https://github.com/zg104/zg104.github.io/blob/master/image/sql7.png?raw=true">
</p>
<h3 id="span-id88.-customer-order-frequencyspan"><span id="8">8. Customer Order Frequency</span></h3>
<p align="center">
	  <img src="https://github.com/zg104/zg104.github.io/blob/master/image/sql8-2.png?raw=true">
</p>
<p>这个题目算是比较复杂的了，我会一步一步拆开讲解！</p>
<p>首先这里有三个 table，分别是 <code>customers</code>、<code>product</code> 和 <code>orders</code>，我们需要从中找出 <code>customer_id</code> 和 <code>name</code> 满足下面两个条件：</p>
<ul>
<li>在2020年6月和7月都有消费</li>
<li>并且消费的金额都不小于$100</li>
</ul>
<p>首先，我们从例子中可以看到，<code>product_id</code> 和 <code>customer_id</code> 可以作为连接表的媒介，并且是不存在其中一个媒介的元素一个表格里有，而另一个表格没有，这就说明我们可以放心使用 <code>inner join</code> 而不用担心 <code>null</code> 会存在的问题！</p>
<p>那么自然我们要把 <code>product</code> 和 <code>orders</code> 连接在一起，因为他们包含了产品的价格和数量，我们需要计算他们的乘积，得出某个人在某个时间在某个产品上花费的总钱数。</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">select</span> 先空着
<span class="token keyword">from</span> product p
<span class="token keyword">join</span> orders o
<span class="token keyword">on</span> p<span class="token punctuation">.</span>product_id <span class="token operator">=</span> o<span class="token punctuation">.</span>product_id
<span class="token comment"># using (product_id)</span>
</code></pre>
<p>那么这样我们就把两个 table 连接起来了，我们要选取这个新表格的哪些列呢？</p>
<p>根据我们所需要满足的条件，肯定需要 <code>customer_id</code>，因为我们需要知道是谁买的；也需要 <code>order_date</code>，因为我们只要找在6月和7月有消费的人；最后还有 <code>price * quantity</code>，因为我们要找到消费总额超过$100的人。</p>
<p>所以我们有</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">select</span> customer_id<span class="token punctuation">,</span> order_date price<span class="token operator">*</span>quantity
<span class="token keyword">from</span> product p
<span class="token keyword">join</span> orders o
<span class="token keyword">on</span> p<span class="token punctuation">.</span>product_id <span class="token operator">=</span> o<span class="token punctuation">.</span>product_id
</code></pre>
<p>然后，我们发现 <code>order_date</code> 是以年月日的形式出现的，但我们需要把他转换成以月为单位，因为我们只要找6或7月的消费的人，不关心具体是哪一天，这里使用了 <a href="https://www.w3schools.com/sql/func_mysql_date_format.asp"><code>date_format</code> </a>，可以对日期进行转换。并且，我们需要针对每个消费者，计算出他们在6月和7月的总消费，所以用 <code>sum</code> 函数和 <code>group by</code> 函数；在这个基础上，我们要限定 <code>order_date</code> 在6到7月内，使用 <code>between and</code>，最后，要保证每人月均总消费不小于$100。</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">select</span> customer_id<span class="token punctuation">,</span> 
	   date_format<span class="token punctuation">(</span>order_date<span class="token punctuation">,</span> <span class="token string">'%Y-%m'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token string">'order_date'</span><span class="token punctuation">,</span> 
	   <span class="token function">sum</span><span class="token punctuation">(</span>price<span class="token operator">*</span>quantity<span class="token punctuation">)</span> <span class="token keyword">as</span> total
<span class="token keyword">from</span> product p
<span class="token keyword">join</span> orders o
<span class="token keyword">on</span> p<span class="token punctuation">.</span>product_id <span class="token operator">=</span> o<span class="token punctuation">.</span>product_id
<span class="token keyword">where</span> order_date <span class="token operator">between</span> <span class="token string">'2020-06-01'</span> <span class="token operator">and</span> <span class="token string">'2020-07-31'</span>
<span class="token keyword">group</span> <span class="token keyword">by</span> <span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span> <span class="token comment"># 也就是group by order_date和customer_id</span>
<span class="token keyword">having</span> total <span class="token operator">&gt;=</span> <span class="token number">100</span>
</code></pre>
<p>结果如下：</p>
<p><code>{"headers": ["customer_id", "order_date", "total"], "values": [[2, "2020-06", 600], [1, "2020-06", 300], [3, "2020-06", 110], [1, "2020-07", 100]]}</code></p>
<p>那么到这里，这道题的雏形已经出来了！我们已经成功找到了6和7月的月均总消费不小于$100的所有人，但是我们要找的人一定要在6和7月都有消费，也就是对于每个消费者，他们在其中出现的次数要等于2！</p>
<p>所以上面的结果成为了我们即将要去搜索的新表格，接下来使用subquery，对其进行进一步搜索。</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">select</span> customer_id<span class="token punctuation">,</span> name
<span class="token keyword">from</span> customers 
<span class="token keyword">where</span> customer_id <span class="token operator">in</span> <span class="token comment"># 从customer表里面找到满足下面括号内容的customer_id</span>
<span class="token punctuation">(</span>
	<span class="token keyword">select</span> customer_id 
	<span class="token keyword">from</span>
		<span class="token punctuation">(</span><span class="token keyword">select</span> customer_id<span class="token punctuation">,</span> 
				date_format<span class="token punctuation">(</span>order_date<span class="token punctuation">,</span> <span class="token string">'%Y-%m'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token string">'order_date'</span><span class="token punctuation">,</span> 
				<span class="token function">sum</span><span class="token punctuation">(</span>price<span class="token operator">*</span>quantity<span class="token punctuation">)</span> <span class="token keyword">as</span> total
		<span class="token keyword">from</span> product p
		<span class="token keyword">join</span> orders o
		<span class="token keyword">on</span> p<span class="token punctuation">.</span>product_id <span class="token operator">=</span> o<span class="token punctuation">.</span>product_id
		<span class="token keyword">where</span> order_date <span class="token operator">between</span> <span class="token string">'2020-06-01'</span> <span class="token operator">and</span> <span class="token string">'2020-07-31'</span>
		<span class="token keyword">group</span> <span class="token keyword">by</span> <span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span>
		<span class="token keyword">having</span> total <span class="token operator">&gt;=</span> <span class="token number">100</span><span class="token punctuation">)</span> tmp <span class="token comment"># tmp就是我们之前建立的新表格</span>
	<span class="token keyword">group</span> <span class="token keyword">by</span> customer_id
	<span class="token keyword">having</span> <span class="token function">count</span><span class="token punctuation">(</span>customer_id<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">2</span> 
	<span class="token comment"># 从新表格里面选出在其中出现次数等于2的消费者</span>
<span class="token punctuation">)</span>
</code></pre>
<p>看着是不是很复杂，其实并没有，真正工作当中，应用当中比这个复杂的要多的多。所以也不要感觉SQL特别简单，一学就会，其实也不尽然（<strong>这道题被归在简单的题集里</strong>）。还有我要建议你要把代码写的稍微“好看”一点，方便别人读懂，如果像下面这么写，估计别人很难看懂你要干什么吧，哪怕这仅仅是20行不到的代码。</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">select</span> customer_id <span class="token keyword">from</span> <span class="token punctuation">(</span><span class="token keyword">select</span> customer_id<span class="token punctuation">,</span> date_format<span class="token punctuation">(</span>order_date<span class="token punctuation">,</span> <span class="token string">'%Y-%m'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token string">'order_date'</span><span class="token punctuation">,</span> <span class="token function">sum</span><span class="token punctuation">(</span>price<span class="token operator">*</span>quantity<span class="token punctuation">)</span> <span class="token keyword">as</span> total
<span class="token keyword">from</span> product p <span class="token keyword">join</span> orders o <span class="token keyword">on</span> p<span class="token punctuation">.</span>product_id <span class="token operator">=</span> o<span class="token punctuation">.</span>product_id
<span class="token keyword">where</span> order_date <span class="token operator">between</span> <span class="token string">'2020-06-01'</span> <span class="token operator">and</span> <span class="token string">'2020-07-31'</span> <span class="token keyword">group</span> <span class="token keyword">by</span> <span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span>
<span class="token keyword">having</span> total <span class="token operator">&gt;=</span> <span class="token number">100</span><span class="token punctuation">)</span> tmp <span class="token keyword">group</span> <span class="token keyword">by</span> customer_id <span class="token keyword">having</span> <span class="token function">count</span><span class="token punctuation">(</span>customer_id<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span>
</code></pre>
<p>看了这个，别人可能会想说。。。</p>
<p align="center">
	  <img src="https://img.gmz88.com/uploadimg/ico/2019/0912/1568251652240815.gif">
</p>
<p align="center">
	  <img src="https://github.com/zg104/zg104.github.io/blob/master/image/sql8-3.png?raw=true">
</p>
<h3 id="span-id99.-customer-placing-the-largest-number-of-ordersspan"><span id="9">9. Customer Placing the Largest Number of Orders</span></h3>
<p>Query the  <strong>customer_number</strong>  from the  <strong><em>orders</em></strong>  table for the customer who has placed the largest number of orders.</p>
<p>It is guaranteed that exactly one customer will have placed more orders than any other customer.</p>
<p>The  <strong><em>orders</em></strong>  table is defined as follows:</p>

<table>
<thead>
<tr>
<th>Column</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>order_number (PK)</td>
<td>int</td>
</tr>
<tr>
<td>customer_number</td>
<td>int</td>
</tr>
<tr>
<td>order_date</td>
<td>date</td>
</tr>
<tr>
<td>required_date</td>
<td>date</td>
</tr>
<tr>
<td>shipped_date</td>
<td>date</td>
</tr>
<tr>
<td>status</td>
<td>char(15)</td>
</tr>
<tr>
<td>comment</td>
<td>char(200)</td>
</tr>
</tbody>
</table><p><strong>Sample Input</strong></p>

<table>
<thead>
<tr>
<th>order_number</th>
<th>customer_number</th>
<th>order_date</th>
<th>required_date</th>
<th>shipped_date</th>
<th>status</th>
<th>comment</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td>2017-04-09</td>
<td>2017-04-13</td>
<td>2017-04-12</td>
<td>Closed</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>2017-04-15</td>
<td>2017-04-20</td>
<td>2017-04-18</td>
<td>Closed</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>3</td>
<td>2017-04-16</td>
<td>2017-04-25</td>
<td>2017-04-20</td>
<td>Closed</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>3</td>
<td>2017-04-18</td>
<td>2017-04-28</td>
<td>2017-04-25</td>
<td>Closed</td>
<td></td>
</tr>
</tbody>
</table><p><strong>Sample Output</strong></p>

<table>
<thead>
<tr>
<th>customer_number</th>
</tr>
</thead>
<tbody>
<tr>
<td>3</td>
</tr>
</tbody>
</table><p><strong>Explanation</strong></p>
<p>The customer with number ‘3’ has two orders, which is greater than either customer ‘1’ or ‘2’ because each of them  only has one order.<br>
So the result is customer_number ‘3’.</p>
<p>要注意，我们保证了只有一个消费者会比其他消费者下更多的单，也就是说我们不必担心会有多个消费者下了同样多的单，并且是最多的。</p>
<p>所以我们可以使用<code>limit</code>函数和<code>order by</code>函数对每个客户下单次数进行降序排序，并且取第一个，也就是最大的那个。</p>
<p><font color="red">正确答案如下：</font></p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">select</span> customer_number
<span class="token keyword">from</span> orders
<span class="token keyword">group</span> <span class="token keyword">by</span> <span class="token number">1</span>  
<span class="token keyword">order</span> <span class="token keyword">by</span> <span class="token function">count</span><span class="token punctuation">(</span>order_number<span class="token punctuation">)</span> <span class="token keyword">desc</span>
<span class="token comment"># 针对每个消费者查找其下单次数，并降序排列</span>
<span class="token keyword">limit</span> <span class="token number">1</span> <span class="token comment"># 取第一个</span>
</code></pre>
<p><strong>Follow up:</strong>  What if more than one customer have the largest number of orders, can you find all the customer_number in this case?</p>
<p>如果面试官抛给了你这样的问题，你还会吗？</p>
<p>首先，降序排列找第一个这种策略已经不适用了，因为有可能出现好几个消费者都下了一样多的单，并且都是最多的，我们也不知道取前几个，这时会用到我们很常用的<strong>window function</strong>来辅助我们进行排序。</p>
<p>先来说一下window function的种类，我想下面这个图可以让你理解这三种排序函数的区别。</p>
<ul>
<li><code>row_number</code>返回从1开始的序列</li>
<li><code>rank</code>返回当前结果中每一个记录的排名</li>
<li><code>dense_rank</code>和<code>rank</code>很像，但是没有gap</li>
</ul>
<p align="center">
	  <img src="https://sqlversity.files.wordpress.com/2013/06/ranking-functions.png
">
</p>
<p>那么我们先对每个消费者的下单数进行降序排序</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">select</span> customer_number<span class="token punctuation">,</span> 
	   rank<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">over</span> <span class="token punctuation">(</span><span class="token keyword">order</span> <span class="token keyword">by</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">desc</span><span class="token punctuation">)</span> <span class="token keyword">as</span> rnk
	   <span class="token comment"># 这里我们使用rank()函数，其实在查找排名第一的情况时，</span>
	   <span class="token comment"># dense_rank()和rank()其实没区别的</span>
<span class="token keyword">from</span> orders
</code></pre>
<p>先重新定义一下我们的输入：</p>
<p><code>{"headers":{"orders":["order_number","customer_number"]},"rows":{"orders":[[1,1],[2,2],[3,3],[4,3],[5,4],[6,4]]}}</code></p>
<p>可以看出，编号为3和4的消费者都下单了两次，并且是最多的。</p>
<p>根据上面的代码，我们得到结果如下：</p>
<p><code>{"headers": ["customer_number", "rnk"], "values": [[3, 1], [4, 1], [1, 3], [2, 3]]}</code></p>
<p>意思是<code>customer_id</code>为3和4的消费者下单量排名第一，那么其他的我们就不考虑了，因为我们只考虑排名第一的。</p>
<p>那么在这个基础上，我们要再从这个新表格里面筛选<code>customer_id</code>满足<code>rnk = 1</code>即可，使用subquery结果如下：</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">select</span> customer_number 
<span class="token keyword">from</span>
<span class="token punctuation">(</span>
	<span class="token keyword">select</span> customer_number<span class="token punctuation">,</span> 
		   rank<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">over</span> <span class="token punctuation">(</span><span class="token keyword">order</span> <span class="token keyword">by</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">desc</span><span class="token punctuation">)</span> <span class="token keyword">as</span> rnk
	<span class="token keyword">from</span> orders
	<span class="token keyword">group</span> <span class="token keyword">by</span> customer_number
<span class="token punctuation">)</span> tmp
<span class="token keyword">where</span> rnk <span class="token operator">=</span> <span class="token number">1</span> <span class="token comment"># 这里要记得用alias哦!</span>
</code></pre>
<p>那么，我现在有一个很欠揍的问题，如果我不想找排名第一的了，我想找排名第二的，而且我也不保证会出现排名第二的消费者下单数都相同的情况哦！</p>
<p align="center">
	  <img src="http://wx4.sinaimg.cn/mw690/6a04b428ly1g19aktss1jg208w050b24.gif
">
</p>
<p align="center">
	  <img src="http://wx4.sinaimg.cn/mw690/6a04b428ly1g19aksio2hg208w050kgp.gif
">
</p>
<p>那么，拯救世界的任务就拜托你了！</p>
<p align="center">
	  <img src="https://github.com/zg104/zg104.github.io/blob/master/image/sql9.png?raw=true">
</p>
<h3 id="span-id1010.-customers-who-never-orderspan"><span id="10">10. Customers Who Never Order</span></h3>
<p>咳咳，那么来点简单的划划水吧！</p>
<p align="center">
	  <img src="https://github.com/zg104/zg104.github.io/blob/master/image/sql10-1.png?raw=true">
</p>
<p>这个题非常的straightforward，就是让我们找所有一毛不拔的顾客，什么都不买的人。</p>
<p>有人说：“见到两个table我就手痒，就想join怎么办？”</p>
<p>join归join，您先想清楚怎么join好伐，之前说过了 <code>inner join</code> 和 <code>left join</code> 的区别。那么既然我们要找没买东西的人，那就是要找两个table连到一起后，orders表格中的<code>Id</code>为<code>null</code>的人嘛！</p>
<p><font color="red">正确答案如下：</font></p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">select</span> Name <span class="token keyword">as</span> <span class="token string">'Customers'</span>
<span class="token keyword">from</span> customers <span class="token keyword">as</span> <span class="token string">'c'</span>
<span class="token keyword">left</span> <span class="token keyword">join</span> orders <span class="token keyword">as</span> <span class="token string">'o'</span>
<span class="token keyword">on</span> <span class="token number">c</span><span class="token punctuation">.</span>Id <span class="token operator">=</span> o<span class="token punctuation">.</span>CustomerId
<span class="token keyword">where</span> o<span class="token punctuation">.</span>Id <span class="token operator">is</span> <span class="token boolean">null</span>
</code></pre>
<p>但是毕竟我们用了join，在跑大型数据集时时间还是会有些长，那么我又变成了坏人，能不能不用join呢？</p>
<p align="center">
	  <img src="http://wx2.sinaimg.cn/mw690/6a04b428ly1g19akufoa6g209q08amy7.gif
">
</p>
<p>那么便是筛选<code>Customers</code>表格中的不在<code>Orders</code>表格中的<code>CustomerId</code>中的<code>Id</code>呗。</p>
<p>Emmmmm我想你应该明白我的意思…</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">select</span> name <span class="token keyword">as</span> <span class="token string">'Customers'</span>
<span class="token keyword">from</span> customers
<span class="token keyword">where</span> id <span class="token operator">not</span> <span class="token operator">in</span> <span class="token comment"># not in 作为筛选条件也真的很常见了！</span>
<span class="token punctuation">(</span>
    <span class="token keyword">select</span> customerid <span class="token keyword">from</span> orders
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p align="center">
	  <img src="https://github.com/zg104/zg104.github.io/blob/master/image/sql10-2.png?raw=true">
</p>
<p>可以看到在不用join的情况下，速度还是快很多的！</p>
<h3 id="span-id1111.-delete-duplicate-emailsspan"><span id="11">11. Delete Duplicate Emails</span></h3>
<p align="center">
	  <img src="https://github.com/zg104/zg104.github.io/blob/master/image/sql11-1.png?raw=true">
</p>
<p>我们要删除所有重复的邮件，并按照只保留<code>Id</code>的结果（如果重复的话）</p>
<p>首先，我们使用self join来满足下列两个条件：</p>
<ul>
<li><code>Email</code>相同</li>
<li>找到重复并且<code>Id</code>大的</li>
</ul>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">select</span> p1<span class="token punctuation">.</span><span class="token operator">*</span>
<span class="token keyword">FROM</span> Person p1<span class="token punctuation">,</span>
     Person p2
<span class="token keyword">WHERE</span>
    p1<span class="token punctuation">.</span>Email <span class="token operator">=</span> p2<span class="token punctuation">.</span>Email 
    <span class="token comment"># Email相同</span>
    <span class="token operator">AND</span> 
    p1<span class="token punctuation">.</span>Id <span class="token operator">&gt;</span> p2<span class="token punctuation">.</span>Id
    <span class="token comment"># 这样保证我们找到了所有重复的email并且找出所有大于最小Id的结果</span>
<span class="token punctuation">;</span>
</code></pre>
<p>上面的结果就是我们要删除的，所以最终答案如下：</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">delete</span> p1<span class="token punctuation">.</span><span class="token operator">*</span>
<span class="token keyword">FROM</span> Person p1<span class="token punctuation">,</span>
     Person p2
<span class="token keyword">WHERE</span>
    p1<span class="token punctuation">.</span>Email <span class="token operator">=</span> p2<span class="token punctuation">.</span>Email 
    <span class="token operator">AND</span> 
    p1<span class="token punctuation">.</span>Id <span class="token operator">&gt;</span> p2<span class="token punctuation">.</span>Id
<span class="token punctuation">;</span>
</code></pre>
<p align="center">
	  <img src="https://github.com/zg104/zg104.github.io/blob/master/image/sql11-2.png?raw=true">
</p>
<h3 id="span-id1212.-duplicate-emailsspan"><span id="12">12. Duplicate Emails</span></h3>
<p align="center">
	  <img src="https://github.com/zg104/zg104.github.io/blob/master/image/sql12-1.png?raw=true">
</p>
<p>这个题是不是很简单，就是要删除重复的邮件，直接上答案了，不会做的要加油啦！</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">select</span> Email 
<span class="token keyword">from</span> Person 
<span class="token keyword">group</span> <span class="token keyword">by</span> Email  
<span class="token comment"># 这个Email是Person表的Email这一列</span>
<span class="token keyword">having</span> <span class="token function">count</span><span class="token punctuation">(</span>Email<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre>
<p align="center">
	  <img src="https://github.com/zg104/zg104.github.io/blob/master/image/sql12-2.png?raw=true">
</p>
</div>
</body>

</html>
