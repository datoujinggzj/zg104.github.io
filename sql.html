<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>sql</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__html"><p align="center">
	  <img src="https://thumbs.gfycat.com/InsistentSardonicAppaloosa-small.gif">
</p>
<h1 id="sql刷题">SQL刷题</h1>
<h2 id="题目">题目</h2>
<h3 id="easy">Easy</h3>
<ol>
<li><a href="#1">Actors and Directors Who Cooperated At Least Three Times</a></li>
<li><a href="#2">Ads Performance</a></li>
<li><a href="#3">Article Views I</a></li>
<li><a href="#4">Average Selling Price</a></li>
<li><a href="#5">Biggest Single Number</a></li>
<li><a href="#6">Combine Two Tables</a></li>
</ol>
<h3 id="span-id11.-actors-and-directors-who-cooperated-at-least-three-timesspan"><span id="1">1. Actors and Directors Who Cooperated At Least Three Times</span></h3>
<p>注意到，这里的table: <code>ActorDirector</code> 包含三列，其中timestamp是<a href="https://www.liaoxuefeng.com/wiki/1177760294764384/1218728391867808">主键</a>。</p>
<p>我们需要找到所有的配对（actor_id, director_id）其中演员和导演合作过至少三次。</p>
<p>所以，我们要求<code>actor_id</code>和<code>director_id</code>配对的数量不小于三，<br>
利用<code>count</code>函数我们有：</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">select</span> actor_id<span class="token punctuation">,</span> director_id<span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">as</span> counts
<span class="token keyword">from</span> actordirector
<span class="token keyword">group</span> <span class="token keyword">by</span> actor_id<span class="token punctuation">,</span> director_id
</code></pre>
<p>这一步的结果如下，我们对应每个演员、导演并且计算出他们合作的次数，分别为3，2，2。</p>
<p><code>{"headers": ["actor_id", "director_id", "c"], "values": [[1, 1, 3], [1, 2, 2], [2, 1, 2]]}</code></p>
<p>如果不清楚<code>group by</code>可以看<a href="https://www.w3schools.com/sql/sql_groupby.asp">这里</a>。</p>
<p>还有，我们可以用<code>group by 1,2</code>来代替<code>group by actor_id, director_id</code>，其实1和2代表的就是<code>select</code>前两列的意思。</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">select</span> actor_id<span class="token punctuation">,</span> director_id<span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">as</span> counts
<span class="token keyword">from</span> actordirector
<span class="token keyword">group</span> <span class="token keyword">by</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span>
</code></pre>
<p>接下来，我们只需在这个基础上找到所有的演员和导演满足<code>counts &gt;= 3</code>即可。</p>
<p><font color="red">最终答案如下：</font></p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">select</span> actor_id<span class="token punctuation">,</span> director_id <span class="token keyword">from</span>
<span class="token punctuation">(</span><span class="token keyword">select</span> actor_id<span class="token punctuation">,</span> director_id<span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">as</span> counts
<span class="token keyword">from</span> actordirector
<span class="token keyword">group</span> <span class="token keyword">by</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> tmp
<span class="token keyword">where</span> counts <span class="token operator">&gt;=</span> <span class="token number">3</span>
</code></pre>
<p>这里使用了十分常见的<a href="https://www.1keydata.com/cn/sql/sql-subquery.php">subquery</a>，其中注意要在table后面加上别名（alias），这里用tmp表示</p>
<p align="center">
	  <img src="https://github.com/zg104/zg104.github.io/blob/master/image/sql1.png?raw=true">
</p>
<h3 id="span-id22.-ads-performancespan"><span id="2">2. Ads Performance</span></h3>
<p>注意，<code>Ads</code>表里面<code>ad_id</code>和<code>user_id</code>是主键，我们需要按照给出的公式算出CTR。</p>
<p>所以根据每个<code>ad_id</code>，我们可以计算出其对应的<code>Clicked</code>和<code>Viewed</code>的个数，在利用公式可求得CTR。</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">select</span> ad_id<span class="token punctuation">,</span>
<span class="token comment"># case when类似于if else语句，表示当action = 'Clicked'记为1，否则记为0,注意一定后面加上end！用sum函数计算每个不同的ad_id对应的Clicked的总数，同理用其除以后面的式子，得到ctr，并用round函数保留两位小数</span>
	<span class="token function">round</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token operator">*</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">case</span> <span class="token keyword">when</span> <span class="token keyword">action</span> <span class="token operator">=</span> <span class="token string">'Clicked'</span> <span class="token keyword">then</span> <span class="token number">1</span> <span class="token keyword">else</span> <span class="token number">0</span> <span class="token keyword">end</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">case</span> <span class="token keyword">when</span> <span class="token keyword">action</span> <span class="token operator">=</span> <span class="token string">'Clicked'</span> <span class="token operator">or</span> <span class="token keyword">action</span> <span class="token operator">=</span> <span class="token string">'Viewed'</span> <span class="token keyword">then</span> <span class="token number">1</span> <span class="token keyword">else</span> <span class="token number">0</span> <span class="token keyword">end</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">as</span> ctr
<span class="token keyword">from</span> ads
<span class="token keyword">group</span> <span class="token keyword">by</span> ad_id <span class="token comment"># 对应每个不同的ad_id</span>
<span class="token keyword">order</span> <span class="token keyword">by</span> ctr <span class="token keyword">desc</span><span class="token punctuation">,</span> ad_id <span class="token keyword">asc</span><span class="token punctuation">;</span> <span class="token comment"># 排序</span>
</code></pre>
<p>结果如下：</p>
<p><code>{"headers": ["ad_id", "ctr"], "values": [[1, 66.67], [3, 50.00], [2, 33.33], [5, null]]}</code></p>
<p>我们发现，当<code>ad_id</code>等于<code>5</code>，ctr为<code>null</code>而不是<code>0.00</code>。所以我们需要对这种情况做些调整，用<code>ifnull</code>函数把<code>null</code>转换成<code>0</code>。</p>
<p><font color="red">最终答案如下：</font></p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token comment"># case when类似于if else语句，表示当action = 'Clicked'记为1，否则记为0,注意一定后面加上end！用sum函数计算每个不同的ad_id对应的Clicked的总数，同理用其除以后面的式子，得到ctr，并用round函数保留两位小数，且用ifnull函数处理缺失值。</span>
<span class="token keyword">select</span> ad_id<span class="token punctuation">,</span>
	ifnull<span class="token punctuation">(</span><span class="token function">round</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token operator">*</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">case</span> <span class="token keyword">when</span> <span class="token keyword">action</span> <span class="token operator">=</span> <span class="token string">'Clicked'</span> <span class="token keyword">then</span> <span class="token number">1</span> <span class="token keyword">else</span> <span class="token number">0</span> <span class="token keyword">end</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">case</span> <span class="token keyword">when</span> <span class="token keyword">action</span> <span class="token operator">=</span> <span class="token string">'Clicked'</span> <span class="token operator">or</span> <span class="token keyword">action</span> <span class="token operator">=</span> <span class="token string">'Viewed'</span> <span class="token keyword">then</span> <span class="token number">1</span> <span class="token keyword">else</span> <span class="token number">0</span> <span class="token keyword">end</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">as</span> ctr
<span class="token keyword">from</span> ads
<span class="token keyword">group</span> <span class="token keyword">by</span> ad_id <span class="token comment"># 对应每个不同的ad_id</span>
<span class="token keyword">order</span> <span class="token keyword">by</span> ctr <span class="token keyword">desc</span><span class="token punctuation">,</span> ad_id <span class="token keyword">asc</span><span class="token punctuation">;</span> <span class="token comment"># 排序</span>
</code></pre>
<p align="center">
	  <img src="https://github.com/zg104/zg104.github.io/blob/master/image/sql2.png?raw=true">
</p>
<h3 id="span-id33.-article-views-ispan"><span id="3">3. Article Views I</span></h3>
<p>Table:  <code>Views</code></p>
<p>±--------------±--------+<br>
| Column Name   | Type    |<br>
±--------------±--------+<br>
| article_id    | int     |<br>
| author_id     | int     |<br>
| viewer_id     | int     |<br>
| view_date     | date    |<br>
±--------------±--------+<br>
注意这里没有主键，说明可能会含有重复的行，每一行表示某个观看者在某个日期观看了某个作者写的某篇文章。</p>
<p><strong>我们要找出所有的观看了至少一篇自己的文章的作者，并且按照他们的id的升序排序。</strong></p>
<p>Views table:<br>
±-----------±----------±----------±-----------+<br>
| article_id | author_id | viewer_id | view_date  |<br>
±-----------±----------±----------±-----------+<br>
| 1          | 3         | 5         | 2019-08-01 |<br>
| 1          | 3         | 6         | 2019-08-02 |<br>
| 2          | 7         | 7         | 2019-08-01 |<br>
| 2          | 7         | 6         | 2019-08-02 |<br>
| 4          | 7         | 1         | 2019-07-22 |<br>
| 3          | 4         | 4         | 2019-07-21 |<br>
| 3          | 4         | 4         | 2019-07-21 |<br>
±–±—±---±--------------+</p>
<p>Result table:<br>
±-----+<br>
| id   |<br>
±-----+<br>
| 4    |<br>
| 7    |<br>
±-----+</p>
<p><font color="red">正确答案如下：</font></p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">select</span> <span class="token keyword">distinct</span> author_id <span class="token keyword">as</span> <span class="token string">'id'</span>
<span class="token keyword">from</span> views
<span class="token keyword">where</span> author_id <span class="token operator">=</span> viewer_id
<span class="token keyword">order</span> <span class="token keyword">by</span> <span class="token number">1</span>

<span class="token comment"># 注意</span>
<span class="token comment"># 1. distinct 函数筛选出了唯一的auther_id，因为可能有重复的行存在</span>
<span class="token comment"># 2. order by 1 = order by author_id</span>
</code></pre>
<p align="center">
	  <img src="https://github.com/zg104/zg104.github.io/blob/master/image/sql3.png?raw=true">
</p>
<h3 id="span-id44.-average-selling-pricespan"><span id="4">4. Average Selling Price</span></h3>
<p>Table: <code>Prices</code><br>
±--------------±--------+<br>
| Column Name   | Type    |<br>
±--------------±--------+<br>
| product_id    | int     |<br>
| start_date    | date    |<br>
| end_date      | date    |<br>
| price         | int     |<br>
±--------------±--------+</p>
<p>这里的 <code>product_id</code>、<code>start_date</code>和 <code>end_date</code> 都是主键，每一行表示了在开始日期到结束日期内的每个 <code>product_id</code> 的价格，并且对于一个 <code>product_id</code>，不会有两个相交的时间区间存在。</p>
<p>Table:  <code>UnitsSold</code><br>
±--------------±--------+<br>
| Column Name   | Type    |<br>
±--------------±--------+<br>
| product_id    | int     |<br>
| purchase_date | date    |<br>
| units         | int     |<br>
±--------------±--------+</p>
<p>这里没有主键，所以有重复的行，每一行表示对于每个卖出的产品的 <code>product_id</code>、<code>purchase_date</code> 和 <code>units</code>。</p>
<p><strong>我们需要找到每个产品的平均售卖价格。</strong></p>
<p>例如：</p>
<p>Prices table:<br>
±-----------±-----------±-----------±-------+<br>
| product_id | start_date | end_date   | price  |<br>
±-----------±-----------±-----------±-------+<br>
| 1          | 2019-02-17 | 2019-02-28 | 5      |<br>
| 1          | 2019-03-01 | 2019-03-22 | 20     |<br>
| 2          | 2019-02-01 | 2019-02-20 | 15     |<br>
| 2          | 2019-02-21 | 2019-03-31 | 30     |<br>
±-----------±-----------±-----------±-------+</p>
<p>UnitsSold table:<br>
±-----------±--------------±------+<br>
| product_id | purchase_date | units |<br>
±-----------±--------------±------+<br>
| 1          | 2019-02-25    | 100   |<br>
| 1          | 2019-03-01    | 15    |<br>
| 2          | 2019-02-10    | 200   |<br>
| 2          | 2019-03-22    | 30    |<br>
±-----------±--------------±------+</p>
<p>Result table:<br>
±-----------±--------------+<br>
| product_id | average_price |<br>
±-----------±--------------+<br>
| 1          | 6.96          |<br>
| 2          | 16.96         |<br>
±-----------±--------------+<br>
Average selling price = Total Price of Product / Number of products sold.<br>
Average selling price for product <code>1 = ((100 * 5) + (15 * 20)) / 115 = 6.96</code><br>
Average selling price for product <code>2 = ((200 * 15) + (30 * 30)) / 230 = 16.96</code></p>
<p><font color="red">正确答案如下：</font></p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">select</span> p<span class="token punctuation">.</span>product_id<span class="token punctuation">,</span> <span class="token function">round</span><span class="token punctuation">(</span><span class="token function">sum</span><span class="token punctuation">(</span>price<span class="token operator">*</span>units<span class="token punctuation">)</span><span class="token operator">/</span><span class="token function">sum</span><span class="token punctuation">(</span>units<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">as</span> average_price
<span class="token keyword">from</span> prices <span class="token keyword">as</span> p
<span class="token keyword">join</span> unitssold <span class="token keyword">as</span> u
<span class="token keyword">using</span> <span class="token punctuation">(</span>product_id<span class="token punctuation">)</span>
<span class="token keyword">where</span> u<span class="token punctuation">.</span>purchase_date <span class="token operator">between</span> p<span class="token punctuation">.</span>start_date <span class="token operator">and</span> p<span class="token punctuation">.</span>end_date
<span class="token keyword">group</span> <span class="token keyword">by</span> p<span class="token punctuation">.</span>product_id

<span class="token comment"># 注意</span>
<span class="token comment"># 1. 对于table要加上alias，并且对于公共的product_id要加上对应的table名</span>
<span class="token comment"># 2. using (product_id) 等价于 on p.product_id = u.product_id</span>
<span class="token comment"># 3. 要保证purchase_date在start_date和end_date中间，可能会被忽略，并且这个条件要在group by之前，因为在aggregate之前我们要筛选出满足时间范围的行，在进行计算！</span>
</code></pre>
<p align="center">
	  <img src="https://github.com/zg104/zg104.github.io/blob/master/image/sql4.png?raw=true">
</p>
<h3 id="span-id55.-biggest-single-numberspan"><span id="5">5. Biggest Single Number</span></h3>
<p>Table  <code>my_numbers</code>  contains many numbers in column  <strong>num</strong>  including duplicated ones.<br>
Can you write a SQL query to find the biggest number, which only appears once.</p>
<p>±–+<br>
|num|<br>
±–+<br>
| 8 |<br>
| 8 |<br>
| 3 |<br>
| 3 |<br>
| 1 |<br>
| 4 |<br>
| 5 |<br>
| 6 |</p>
<p>For the sample data above, your query should return the following result:</p>
<p>±–+<br>
|num|<br>
±–+<br>
| 6 |</p>
<p><strong>Note:</strong><br>
If there is no such number, just output <strong>null</strong>.</p>
<p>那么我们要找的就是num里面只出现一次的最大的数</p>
<p>可能你会这么写</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">select</span> <span class="token function">max</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token string">'num'</span>
<span class="token keyword">from</span> my_number
<span class="token keyword">group</span> <span class="token keyword">by</span> num
<span class="token keyword">having</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1</span>
</code></pre>
<p>但这样会返回错误的值，如下：</p>
<p><code>{"headers": ["num"], "values": [[1], [4], [5], [6]]}</code></p>
<p>我们是找出了出现次数为1的数字但是max函数貌似不起作用，因为这里的<code>max(num)</code>针对的是num，相当于对每一个group by的数字都取了最大值，也就是本身，所以无效</p>
<p><font color="red">正确答案如下：</font></p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">select</span> <span class="token function">max</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token keyword">as</span> num
<span class="token keyword">from</span>
<span class="token punctuation">(</span><span class="token keyword">select</span>
    num
<span class="token keyword">from</span>
    my_numbers
<span class="token keyword">group</span> <span class="token keyword">by</span> num
<span class="token keyword">having</span> <span class="token function">count</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">as</span> tmp
<span class="token comment"># 使用subquery对所有出现次数为1的数字取最大值</span>
</code></pre>
<p>或者</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">select</span> <span class="token function">max</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token keyword">as</span> num
<span class="token keyword">from</span>
<span class="token punctuation">(</span><span class="token keyword">select</span>
    num<span class="token punctuation">,</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">as</span> counts
<span class="token keyword">from</span>
    my_numbers
<span class="token keyword">group</span> <span class="token keyword">by</span> num<span class="token punctuation">)</span> <span class="token keyword">as</span> tmp
<span class="token keyword">where</span> counts <span class="token operator">=</span> <span class="token number">1</span>
</code></pre>
<p align="center">
	  <img src="https://github.com/zg104/zg104.github.io/blob/master/image/sql5.png?raw=true">
</p>
<h3 id="span-id66.-combine-two-tablesspan"><span id="6">6. Combine Two Tables</span></h3>
<p>Table:  <code>Person</code></p>
<p>±------------±--------+<br>
| Column Name | Type    |<br>
±------------±--------+<br>
| PersonId    | int     |<br>
| FirstName   | varchar |<br>
| LastName    | varchar |<br>
±------------±--------+<br>
PersonId is the primary key column for this table.</p>
<p>Table:  <code>Address</code></p>
<p>±------------±--------+<br>
| Column Name | Type    |<br>
±------------±--------+<br>
| AddressId   | int     |<br>
| PersonId    | int     |<br>
| City        | varchar |<br>
| State       | varchar |<br>
±------------±--------+<br>
AddressId is the primary key column for this table.</p>
<p>Write a SQL query for a report that provides the following information for each person in the Person table, regardless if there is an address for each of those people:</p>
<p><code>FirstName, LastName, City, State</code></p>
<p>这个题看似很简单，只需要把他们合并起来就可以了，但是要注意<code>inner join</code>和<code>left join</code>的区别（<code>right join</code>其实和<code>left join</code>是一回事）。</p>
<p>一图流！</p>
<p align="center">
	  <img src="https://i.stack.imgur.com/fzwkg.png">
</p>
<p>这里题目要求我们找出每个人的各种信息，无论这个人是不是有地址，也就是哪怕没有地址，也要用<code>null</code>表示，那自然要用<code>left join</code>。</p>
<p><font color="red">正确答案如下：</font></p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">select</span> FirstName<span class="token punctuation">,</span> LastName<span class="token punctuation">,</span> City<span class="token punctuation">,</span> State
<span class="token keyword">from</span> Person <span class="token keyword">left</span> <span class="token keyword">join</span> Address
<span class="token keyword">on</span> Person<span class="token punctuation">.</span>PersonId <span class="token operator">=</span> Address<span class="token punctuation">.</span>PersonId
<span class="token comment"># using (PersonId)</span>
</code></pre>
<p>结果如下：</p>
<p><code>{"headers": ["FirstName", "LastName", "City", "State"], "values": [["Allen", "Wang", null, null]]}</code></p>
<p align="center">
	  <img src="https://github.com/zg104/zg104.github.io/blob/master/image/sql6.png?raw=true">
</p>
</div>
</body>

</html>
